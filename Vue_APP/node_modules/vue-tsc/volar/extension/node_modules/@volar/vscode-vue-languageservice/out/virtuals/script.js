"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useScriptSetupGen = void 0;
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const shared_1 = require("@volar/shared");
const reactivity_1 = require("@vue/reactivity");
const sourceMaps_1 = require("../utils/sourceMaps");
const scriptAst_1 = require("../parsers/scriptAst");
const scriptSetupAst_1 = require("../parsers/scriptSetupAst");
const script_1 = require("../generators/script");
const script_suggestion_1 = require("../generators/script_suggestion");
const templateGen = require("../generators/template_scriptSetup");
function useScriptSetupGen(ts, vueDoc, script, scriptSetup, html) {
    let version = 0;
    const uri = vueDoc.value.uri;
    const scriptAst = reactivity_1.computed(() => script.value
        ? scriptAst_1.parse(ts, script.value.content)
        : undefined);
    const scriptSetupAst = reactivity_1.computed(() => scriptSetup.value
        ? scriptSetupAst_1.parse(ts, scriptSetup.value.content)
        : undefined);
    const codeGen = reactivity_1.computed(() => script_1.generate(script.value, scriptSetup.value, scriptAst.value, scriptSetupAst.value));
    const htmlGen = reactivity_1.computed(() => {
        if (html.value) {
            return templateGen.generate(html.value);
        }
    });
    const suggestionCodeGen = reactivity_1.computed(() => script_suggestion_1.generate(script.value, scriptSetup.value, scriptSetupAst.value, htmlGen.value));
    const lang = reactivity_1.computed(() => {
        return scriptSetup.value && scriptSetup.value.lang !== 'js' ? shared_1.getValidScriptSyntax(scriptSetup.value.lang) :
            script.value && script.value.lang !== 'js' ? shared_1.getValidScriptSyntax(script.value.lang) :
                shared_1.getValidScriptSyntax('js');
    });
    const textDocument = reactivity_1.computed(() => {
        if (!codeGen.value)
            return;
        return vscode_languageserver_textdocument_1.TextDocument.create(`${uri}.__VLS_script.${lang.value}`, shared_1.syntaxToLanguageId(lang.value), version++, codeGen.value.getText());
    });
    const textDocumentForSuggestion = reactivity_1.computed(() => {
        if (!suggestionCodeGen.value)
            return;
        return vscode_languageserver_textdocument_1.TextDocument.create(`${uri}.__VLS_script.suggestion.${lang.value}`, shared_1.syntaxToLanguageId(lang.value), version++, suggestionCodeGen.value.getText());
    });
    const textDocumentForTemplate = reactivity_1.computed(() => {
        if (!textDocument.value)
            return;
        if (textDocument.value.languageId !== 'javascript')
            return;
        const lang = 'ts';
        return vscode_languageserver_textdocument_1.TextDocument.create(`${uri}.__VLS_script.${lang}`, shared_1.syntaxToLanguageId(lang), textDocument.value.version, textDocument.value.getText());
    });
    const sourceMap = reactivity_1.computed(() => {
        var _a;
        if (!codeGen.value)
            return;
        if (!textDocument.value)
            return;
        const sourceMap = new sourceMaps_1.TsSourceMap(vueDoc.value, textDocument.value, false, {
            foldingRanges: false,
            formatting: false,
            documentSymbol: true,
            codeActions: true,
            organizeImports: !((_a = script.value) === null || _a === void 0 ? void 0 : _a.src) && !scriptSetup.value,
        }, codeGen.value.getMappings(parseMappingSourceRange));
        return sourceMap;
    });
    const sourceMapForSuggestion = reactivity_1.computed(() => {
        if (!suggestionCodeGen.value)
            return;
        if (!textDocumentForSuggestion.value)
            return;
        const sourceMap = new sourceMaps_1.TsSourceMap(vueDoc.value, textDocumentForSuggestion.value, false, {
            foldingRanges: false,
            formatting: false,
            documentSymbol: false,
            codeActions: true,
            organizeImports: true,
        }, suggestionCodeGen.value.getMappings(parseMappingSourceRange));
        return sourceMap;
    });
    const sourceMapForTemplate = reactivity_1.computed(() => {
        if (!textDocumentForTemplate.value)
            return;
        if (!sourceMap.value)
            return;
        const newSourceMap = new sourceMaps_1.TsSourceMap(sourceMap.value.sourceDocument, textDocumentForTemplate.value, sourceMap.value.isInterpolation, {
            foldingRanges: false,
            formatting: false,
            documentSymbol: false,
            codeActions: false,
            organizeImports: false,
        });
        for (const maped of sourceMap.value) {
            newSourceMap.add({
                ...maped,
                data: {
                    ...maped.data,
                    capabilities: {
                        references: maped.data.capabilities.references,
                        definitions: maped.data.capabilities.definitions,
                        rename: maped.data.capabilities.rename,
                        referencesCodeLens: maped.data.capabilities.referencesCodeLens,
                    },
                },
            });
        }
        return newSourceMap;
    });
    const teleportSourceMap = reactivity_1.computed(() => {
        var _a;
        const doc = (_a = textDocumentForTemplate.value) !== null && _a !== void 0 ? _a : textDocument.value;
        if (!doc)
            return;
        if (!codeGen.value)
            return;
        const sourceMap = new sourceMaps_1.TeleportSourceMap(doc);
        for (const teleport of codeGen.value.teleports) {
            sourceMap.add(teleport);
        }
        return sourceMap;
    });
    return {
        scriptSetupAst,
        textDocument,
        textDocumentForSuggestion,
        textDocumentForTemplate,
        sourceMap,
        sourceMapForSuggestion,
        sourceMapForTemplate,
        teleportSourceMap,
    };
    function parseMappingSourceRange(data, sourceRange) {
        var _a;
        if (data.vueTag === 'scriptSrc' && ((_a = script.value) === null || _a === void 0 ? void 0 : _a.src)) {
            const vueStart = script.value.content.length
                ? vueDoc.value.getText().substring(0, script.value.loc.start).lastIndexOf(script.value.src)
                : (vueDoc.value.getText().substring(script.value.loc.start).indexOf(script.value.src) + script.value.loc.start); // TODO: don't use indexOf()
            const vueEnd = vueStart + script.value.src.length;
            return {
                start: vueStart - 1,
                end: vueEnd + 1,
            };
        }
        else if (data.vueTag === 'script' && script.value) {
            return {
                start: script.value.loc.start + sourceRange.start,
                end: script.value.loc.start + sourceRange.end,
            };
        }
        else if (data.vueTag === 'scriptSetup' && scriptSetup.value) {
            return {
                start: scriptSetup.value.loc.start + sourceRange.start,
                end: scriptSetup.value.loc.start + sourceRange.end,
            };
        }
        else {
            return sourceRange;
        }
    }
}
exports.useScriptSetupGen = useScriptSetupGen;
//# sourceMappingURL=script.js.map