"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const node_1 = require("vscode-languageserver/node");
const definition_1 = require("./definition");
function register({ mapper }) {
    const findDefinitions = definition_1.register(arguments[0]);
    return (uri, position) => {
        var _a, _b;
        const tsResult = onTs(uri, position);
        const htmlResult = onHtml(uri, position);
        const cssResult = onCss(uri, position);
        if (!tsResult && !htmlResult && !cssResult)
            return;
        const texts = [
            ...getHoverTexts(tsResult),
            ...getHoverTexts(htmlResult),
            ...getHoverTexts(cssResult),
        ];
        const result = {
            contents: texts,
            range: (_b = (_a = cssResult === null || cssResult === void 0 ? void 0 : cssResult.range) !== null && _a !== void 0 ? _a : htmlResult === null || htmlResult === void 0 ? void 0 : htmlResult.range) !== null && _b !== void 0 ? _b : tsResult === null || tsResult === void 0 ? void 0 : tsResult.range,
        };
        return result;
    };
    function onTs(uri, position, isExtra = false) {
        let result;
        // vue -> ts
        for (const tsRange of mapper.ts.to(uri, position)) {
            if (!tsRange.data.capabilities.basic)
                continue;
            const tsHover = tsRange.languageService.doHover(tsRange.textDocument.uri, tsRange.start, isExtra);
            if (!tsHover)
                continue;
            if (!isExtra && tsRange.data.capabilities.extraHoverInfo) {
                const definitions = findDefinitions.on(uri, position);
                for (const definition of definitions) {
                    const extraHover = onTs(definition.targetUri, definition.targetSelectionRange.start, true);
                    if (!extraHover)
                        continue;
                    if (!node_1.MarkupContent.is(extraHover.contents))
                        continue;
                    const extraText = extraHover.contents.value;
                    for (const extraTextPart of extraText.split('\n\n')) {
                        if (node_1.MarkupContent.is(tsHover.contents) && !tsHover.contents.value.split('\n\n').includes(extraTextPart)) {
                            tsHover.contents.value += `\n\n` + extraTextPart;
                        }
                    }
                }
            }
            if (tsHover.range) {
                // ts -> vue
                for (const vueRange of mapper.ts.from(tsRange.textDocument.uri, tsHover.range.start, tsHover.range.end)) {
                    result = {
                        ...tsHover,
                        range: vueRange,
                    };
                }
            }
            else {
                result = tsHover;
            }
        }
        return result;
    }
    function onHtml(uri, position) {
        let result;
        // vue -> html
        for (const htmlRange of mapper.html.to(uri, position)) {
            const htmlHover = htmlRange.language === 'html'
                ? htmlRange.languageService.doHover(htmlRange.textDocument, htmlRange.start, htmlRange.htmlDocument)
                : htmlRange.languageService.doHover(htmlRange.pugDocument, htmlRange.start);
            if (!htmlHover)
                continue;
            if (!htmlHover.range) {
                result = htmlHover;
                continue;
            }
            // html -> vue
            for (const vueRange of mapper.html.from(htmlRange.textDocument.uri, htmlHover.range.start, htmlHover.range.end)) {
                result = {
                    ...htmlHover,
                    range: vueRange,
                };
            }
        }
        return result;
    }
    function onCss(uri, position) {
        let result;
        // vue -> css
        for (const cssMaped of mapper.css.to(uri, position)) {
            const cssHover = cssMaped.languageService.doHover(cssMaped.textDocument, cssMaped.start, cssMaped.stylesheet);
            if (!cssHover)
                continue;
            if (!cssHover.range) {
                result = cssHover;
                continue;
            }
            // css -> vue
            for (const vueRange of mapper.css.from(cssMaped.textDocument.uri, cssHover.range.start, cssHover.range.end)) {
                result = {
                    ...cssHover,
                    range: vueRange,
                };
            }
        }
        return result;
    }
}
exports.register = register;
function getHoverTexts(hover) {
    if (!hover) {
        return [];
    }
    if (typeof hover.contents === 'string') {
        return [hover.contents];
    }
    if (node_1.MarkupContent.is(hover.contents)) {
        return [hover.contents.value];
    }
    if (Array.isArray(hover.contents)) {
        return hover.contents;
    }
    return [hover.contents.value];
}
//# sourceMappingURL=hover.js.map