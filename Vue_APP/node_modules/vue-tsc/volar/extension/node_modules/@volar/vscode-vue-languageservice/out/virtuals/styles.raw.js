"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useStylesRaw = void 0;
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const reactivity_1 = require("@vue/reactivity");
const SourceMaps = require("../utils/sourceMaps");
const languageServices = require("../utils/languageServices");
const shared_1 = require("@volar/shared");
const upath = require("upath");
function useStylesRaw(ts, tsLanguageService, getUnreactiveDoc, styles, mode) {
    let version = 0;
    const textDocuments = reactivity_1.computed(() => {
        const vueDoc = getUnreactiveDoc();
        const compilerHost = ts.createCompilerHost(tsLanguageService.host.getCompilationSettings());
        const documentContext = {
            resolveReference: (ref, base) => {
                return resolvePath(ref, base);
            },
        };
        const documents = [];
        for (let i = 0; i < styles.value.length; i++) {
            const style = styles.value[i];
            const lang = style.lang;
            let content = style.content;
            if (lang === 'postcss' && mode === 'api') {
                // TODO: this is temporarily fix, wait for https://github.com/microsoft/vscode-css-languageservice/issues/237
                const lines = style.content.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    let trimedLine = line.trim();
                    if (trimedLine.startsWith('@') && trimedLine.endsWith(';')) {
                        const offset = line.length - line.trimStart().length;
                        const parts = line.substring(offset).split(' ');
                        lines[i] = line.substring(0, offset) + parts[0] + ' ' + parts.slice(1).join('_');
                    }
                }
                content = lines.join('\n');
            }
            const documentUri = vueDoc.uri + '.' + i + '.' + lang;
            const document = vscode_languageserver_textdocument_1.TextDocument.create(documentUri, lang, version++, content);
            const linkStyles = [];
            let stylesheet = undefined;
            const cssLanguageService = languageServices.getCssLanguageService(lang);
            if (cssLanguageService) {
                stylesheet = cssLanguageService.parseStylesheet(document);
                findLinks(cssLanguageService, document, stylesheet);
            }
            documents.push({
                textDocument: document,
                stylesheet,
                links: linkStyles,
                module: style.module,
                scoped: style.scoped,
            });
            function findLinks(ls1, textDocument, stylesheet) {
                const links = ls1.findDocumentLinks(textDocument, stylesheet, documentContext);
                for (const link of links) {
                    if (!link.target)
                        continue;
                    if (!link.target.endsWith('.css') && !link.target.endsWith('.scss') && !link.target.endsWith('.less'))
                        continue;
                    if (!ts.sys.fileExists(shared_1.uriToFsPath(link.target)))
                        continue;
                    if (linkStyles.find(l => l.textDocument.uri === link.target))
                        continue; // Loop
                    const text = ts.sys.readFile(shared_1.uriToFsPath(link.target));
                    if (text === undefined)
                        continue;
                    const lang = upath.extname(link.target).substr(1);
                    const doc = vscode_languageserver_textdocument_1.TextDocument.create(link.target, lang, version++, text);
                    const ls2 = languageServices.getCssLanguageService(lang);
                    if (!ls2)
                        continue;
                    const stylesheet = ls2.parseStylesheet(doc);
                    linkStyles.push({
                        textDocument: doc,
                        stylesheet,
                    });
                    findLinks(ls2, doc, stylesheet);
                }
            }
        }
        return documents;
        function resolvePath(ref, base) {
            const resolveResult = ts.resolveModuleName(ref, base, tsLanguageService.host.getCompilationSettings(), compilerHost);
            const failedLookupLocations = resolveResult.failedLookupLocations;
            for (const failed of failedLookupLocations) {
                let path = failed;
                if (path.endsWith('.d.ts')) {
                    path = upath.trimExt(path);
                    path = upath.trimExt(path);
                }
                else {
                    path = upath.trimExt(path);
                }
                if (ts.sys.fileExists(shared_1.uriToFsPath(path))) {
                    return path;
                }
            }
            return ref;
        }
    });
    const sourceMaps = reactivity_1.computed(() => {
        const vueDoc = getUnreactiveDoc();
        const sourceMaps = [];
        for (let i = 0; i < styles.value.length && i < textDocuments.value.length; i++) {
            const cssData = textDocuments.value[i];
            const style = styles.value[i];
            const document = cssData.textDocument;
            const stylesheet = cssData.stylesheet;
            const linkStyles = cssData.links;
            const loc = style.loc;
            const module = style.module;
            const scoped = style.scoped;
            const sourceMap = new SourceMaps.CssSourceMap(vueDoc, document, stylesheet, module, scoped, linkStyles, { foldingRanges: true, formatting: true });
            sourceMap.add({
                data: undefined,
                mode: SourceMaps.Mode.Offset,
                sourceRange: {
                    start: loc.start,
                    end: loc.end,
                },
                mappedRange: {
                    start: 0,
                    end: loc.end - loc.start,
                },
            });
            sourceMaps.push(sourceMap);
        }
        return sourceMaps;
    });
    return {
        textDocuments,
        sourceMaps,
    };
}
exports.useStylesRaw = useStylesRaw;
//# sourceMappingURL=styles.raw.js.map