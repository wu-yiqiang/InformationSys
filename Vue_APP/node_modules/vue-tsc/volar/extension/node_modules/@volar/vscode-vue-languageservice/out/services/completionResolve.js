"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const transforms_1 = require("@volar/transforms");
const node_1 = require("vscode-languageserver/node");
function register({ sourceFiles, tsLanguageService }) {
    return (item, newOffset) => {
        const data = item.data;
        const sourceFile = sourceFiles.get(data.uri);
        if (!sourceFile)
            return item;
        if (data.mode === 'ts') {
            return getTsResult(sourceFile, item, data);
        }
        if (data.mode === 'html') {
            return getHtmlResult(sourceFile, item, data);
        }
        return item;
        function getTsResult(sourceFile, vueItem, data) {
            for (const sourceMap of sourceFile.getTsSourceMaps()) {
                if (sourceMap.mappedDocument.uri !== data.docUri)
                    continue;
                let newTsOffset;
                if (newOffset) {
                    for (const tsRange of sourceMap.getMappedRanges2(newOffset)) {
                        if (!tsRange.data.capabilities.completion)
                            continue;
                        newTsOffset = tsRange.start;
                        break;
                    }
                }
                data.tsItem = tsLanguageService.doCompletionResolve(data.tsItem, newTsOffset);
                const newVueItem = transforms_1.transformCompletionItem(data.tsItem, tsRange => sourceMap.getSourceRange(tsRange.start, tsRange.end));
                newVueItem.data = data;
                // TODO: this is a patch for import ts file icon
                if (newVueItem.detail !== data.tsItem.detail + '.ts') {
                    newVueItem.detail = data.tsItem.detail;
                }
                return newVueItem;
            }
            return vueItem;
        }
        function getHtmlResult(sourceFile, vueItem, data) {
            var _a, _b;
            let tsItem = data.tsItem;
            if (!tsItem)
                return vueItem;
            tsItem = tsLanguageService.doCompletionResolve(tsItem);
            vueItem.tags = [...(_a = vueItem.tags) !== null && _a !== void 0 ? _a : [], ...(_b = tsItem.tags) !== null && _b !== void 0 ? _b : []];
            const details = [];
            const documentations = [];
            if (vueItem.detail)
                details.push(vueItem.detail);
            if (tsItem.detail)
                details.push(tsItem.detail);
            if (details.length) {
                vueItem.detail = details.join('\n\n');
            }
            if (vueItem.documentation)
                documentations.push(typeof vueItem.documentation === 'string' ? vueItem.documentation : vueItem.documentation.value);
            if (tsItem.documentation)
                documentations.push(typeof tsItem.documentation === 'string' ? tsItem.documentation : tsItem.documentation.value);
            if (documentations.length) {
                vueItem.documentation = {
                    kind: node_1.MarkupKind.Markdown,
                    value: documentations.join('\n\n'),
                };
            }
            return vueItem;
        }
    };
}
exports.register = register;
//# sourceMappingURL=completionResolve.js.map