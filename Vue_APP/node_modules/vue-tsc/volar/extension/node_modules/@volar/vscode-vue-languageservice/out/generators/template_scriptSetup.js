"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
const vueDom = require("@vue/compiler-dom");
const compiler_core_1 = require("@vue/compiler-core");
const template_1 = require("./template");
function generate(html) {
    let node;
    let text = '';
    const tags = new Set();
    try {
        node = vueDom.compile(html, { onError: () => { } }).ast;
        for (const child of node.children) {
            visitNode(child);
        }
    }
    catch { }
    return {
        text,
        tags,
    };
    function visitNode(node) {
        var _a, _b;
        if (node.type === 1 /* ELEMENT */) {
            // TODO: track https://github.com/vuejs/vue-next/issues/3498
            const forDirective = node.props.find((prop) => prop.type === 7 /* DIRECTIVE */
                && prop.name === 'for');
            if (forDirective) {
                node.props = node.props.filter(prop => prop !== forDirective);
                let forNode;
                compiler_core_1.processFor(node, forDirective, template_1.transformContext, _forNode => {
                    forNode = _forNode;
                    return undefined;
                });
                if (forNode) {
                    forNode.children = [node];
                    visitNode(forNode);
                    return;
                }
            }
            tags.add(node.tag);
            text += `{\n`;
            for (const prop of node.props) {
                if (prop.type === 7 /* DIRECTIVE */
                    && ((_a = prop.exp) === null || _a === void 0 ? void 0 : _a.type) === 4 /* SIMPLE_EXPRESSION */) {
                    if (prop.name === 'slot') {
                        text += `let ${prop.exp.content} = {} as any;\n`;
                    }
                    else if (prop.name === 'on') {
                        text += `() => { ${prop.exp.content} };\n`;
                    }
                    else {
                        text += `(${prop.exp.content});\n`;
                    }
                }
                else if (prop.type === 6 /* ATTRIBUTE */
                    && prop.name === 'ref'
                    && prop.value) {
                    text += `// @ts-ignore\n`;
                    text += `(${prop.value.content});\n`;
                }
            }
            for (const childNode of node.children) {
                visitNode(childNode);
            }
            text += '}\n';
        }
        else if (node.type === 12 /* TEXT_CALL */) {
            // {{ var }}
            visitNode(node.content);
        }
        else if (node.type === 8 /* COMPOUND_EXPRESSION */) {
            // {{ ... }} {{ ... }}
            for (const childNode of node.children) {
                if (typeof childNode === 'object') {
                    visitNode(childNode);
                }
            }
        }
        else if (node.type === 5 /* INTERPOLATION */) {
            // {{ ... }}
            const context = node.loc.source.substring(2, node.loc.source.length - 2);
            text += `{ ${context} };\n`;
        }
        else if (node.type === 9 /* IF */) {
            // v-if / v-else-if / v-else
            for (let i = 0; i < node.branches.length; i++) {
                const branch = node.branches[i];
                if (i === 0)
                    text += 'if';
                else if (branch.condition)
                    text += 'else if';
                else
                    text += 'else';
                if (((_b = branch.condition) === null || _b === void 0 ? void 0 : _b.type) === 4 /* SIMPLE_EXPRESSION */) {
                    text += ` (${branch.condition.content})`;
                }
                text += ` {\n`;
                for (const childNode of branch.children) {
                    visitNode(childNode);
                }
                text += '}\n';
            }
        }
        else if (node.type === 11 /* FOR */) {
            // v-for
            const source = node.parseResult.source;
            const value = node.parseResult.value;
            const key = node.parseResult.key;
            const index = node.parseResult.index;
            if (source.type === 4 /* SIMPLE_EXPRESSION */
                && (value === null || value === void 0 ? void 0 : value.type) === 4 /* SIMPLE_EXPRESSION */) {
                text += `for (let ${value.content} of ${source.content}) {\n`;
                if ((key === null || key === void 0 ? void 0 : key.type) === 4 /* SIMPLE_EXPRESSION */)
                    text += `let ${key.content} = {} as any;`;
                if ((index === null || index === void 0 ? void 0 : index.type) === 4 /* SIMPLE_EXPRESSION */)
                    text += `let ${index.content} = {} as any;`;
                for (const childNode of node.children) {
                    visitNode(childNode);
                }
                text += '}\n';
            }
        }
    }
    ;
}
exports.generate = generate;
//# sourceMappingURL=template_scriptSetup.js.map