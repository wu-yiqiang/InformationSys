"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const dedupe = require("../utils/dedupe");
function register({ mapper }) {
    return {
        on: (uri, position) => {
            const tsResult = onTs(uri, position, 'definition');
            if (tsResult.length) {
                return dedupe.withLocationLinks([
                    ...tsResult,
                ]);
            }
            const cssResult = onCss(uri, position);
            return dedupe.withLocations([
                ...cssResult,
            ]);
        },
        onType: (uri, position) => {
            const tsResult = onTs(uri, position, 'typeDefinition');
            return dedupe.withLocationLinks([
                ...tsResult,
            ]);
        },
    };
    function onTs(uri, position, mode) {
        const loopChecker = dedupe.createLocationSet();
        let tsResult = [];
        let vueResult = [];
        // vue -> ts
        for (const tsRange of mapper.ts.to(uri, position)) {
            if (!tsRange.data.capabilities.definitions)
                continue;
            withTeleports(tsRange.textDocument.uri, tsRange.start, true);
            function withTeleports(uri, position, isOriginal) {
                const tsLocs = mode === 'typeDefinition'
                    ? tsRange.languageService.findTypeDefinition(uri, position)
                    : tsRange.languageService.findDefinition(uri, position);
                tsResult = tsResult.concat(tsLocs.map(tsLoc => ({
                    ...tsLoc,
                    originalUri: uri,
                    isOriginal,
                })));
                for (const location of tsLocs) {
                    loopChecker.add({ uri: location.targetUri, range: location.targetSelectionRange });
                    for (const teleRange of mapper.ts.teleports(location.targetUri, location.targetSelectionRange.start, location.targetSelectionRange.end)) {
                        if (!teleRange.sideData.capabilities.definitions)
                            continue;
                        if (loopChecker.has({ uri: location.targetUri, range: teleRange }))
                            continue;
                        withTeleports(location.targetUri, teleRange.start, false);
                    }
                }
            }
        }
        // ts -> vue
        let originSelectionRange;
        for (const tsLoc of tsResult) {
            if (tsLoc.isOriginal && tsLoc.originSelectionRange) {
                const ranges = mapper.ts.from(tsLoc.originalUri, tsLoc.originSelectionRange.start, tsLoc.originSelectionRange.end);
                if (ranges.length) {
                    originSelectionRange = ranges[0];
                }
            }
        }
        for (const tsLoc of tsResult) {
            const targetSelectionRange = mapper.ts.from(tsLoc.targetUri, tsLoc.targetSelectionRange.start, tsLoc.targetSelectionRange.end);
            if (!targetSelectionRange.length)
                continue;
            const targetRange = mapper.ts.from(tsLoc.targetUri, tsLoc.targetRange.start, tsLoc.targetRange.end);
            vueResult.push({
                targetUri: targetSelectionRange[0].textDocument.uri,
                targetRange: targetRange.length ? targetRange[0] : targetSelectionRange[0],
                targetSelectionRange: targetSelectionRange[0],
                originSelectionRange,
            });
        }
        return vueResult;
    }
    function onCss(uri, position) {
        let cssResult = [];
        let vueResult = [];
        // vue -> css
        for (const cssRange of mapper.css.to(uri, position)) {
            const cssLoc = cssRange.languageService.findDefinition(cssRange.textDocument, cssRange.start, cssRange.stylesheet);
            if (cssLoc) {
                cssResult.push(cssLoc);
            }
        }
        // css -> vue
        for (const cssLoc of cssResult) {
            for (const vueRange of mapper.css.from(cssLoc.uri, cssLoc.range.start, cssLoc.range.end)) {
                vueResult.push({
                    uri: vueRange.textDocument.uri,
                    range: vueRange,
                });
            }
        }
        return vueResult;
    }
}
exports.register = register;
//# sourceMappingURL=definition.js.map