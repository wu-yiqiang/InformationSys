"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = exports.semanticTokenLegend = void 0;
const node_1 = require("vscode-languageserver/node");
const shared_1 = require("@vue/shared");
const languageServices = require("../utils/languageServices");
const html = require("vscode-html-languageservice");
const ts2 = require("@volar/vscode-typescript-languageservice");
const tsLegend = ts2.getSemanticTokenLegend();
const tokenTypesLegend = [
    ...tsLegend.types,
    'componentTag',
    'refLabel',
    'refVariable',
    'refVariableRaw',
];
const tokenTypes = new Map(tokenTypesLegend.map((t, i) => [t, i]));
exports.semanticTokenLegend = {
    tokenTypes: tokenTypesLegend,
    tokenModifiers: tsLegend.modifiers,
};
function register({ sourceFiles, tsLanguageService }) {
    return (document, range, cancle, resultProgress) => {
        const sourceFile = sourceFiles.get(document.uri);
        if (!sourceFile)
            return;
        const offsetRange = range ?
            {
                start: document.offsetAt(range.start),
                end: document.offsetAt(range.end),
            } : {
            start: 0,
            end: document.getText().length,
        };
        const templateScriptData = sourceFile.getTemplateScriptData();
        const htmlElementsSet = new Set(templateScriptData.htmlElements);
        const components = new Set([
            ...templateScriptData.components,
            ...templateScriptData.components.map(shared_1.hyphenate),
        ].filter(name => !htmlElementsSet.has(name)));
        let tokens = [];
        if (cancle === null || cancle === void 0 ? void 0 : cancle.isCancellationRequested)
            return;
        const htmlResult = getHtmlResult(sourceFile);
        if (htmlResult.length) {
            tokens = tokens.concat(htmlResult);
            resultProgress === null || resultProgress === void 0 ? void 0 : resultProgress.report(buildTokens(tokens));
        }
        if (cancle === null || cancle === void 0 ? void 0 : cancle.isCancellationRequested)
            return;
        const scriptSetupResult = getScriptSetupResult(sourceFile);
        if (scriptSetupResult.length) {
            tokens = tokens.concat(scriptSetupResult);
            resultProgress === null || resultProgress === void 0 ? void 0 : resultProgress.report(buildTokens(tokens));
        }
        if (cancle === null || cancle === void 0 ? void 0 : cancle.isCancellationRequested)
            return;
        let tsResult = getTsResult(sourceFile);
        tsResult = tsResult.filter(tsToken => {
            for (const setupToken of scriptSetupResult) {
                if (setupToken[0] === tsToken[0]
                    && setupToken[1] >= tsToken[1]
                    && setupToken[2] <= tsToken[2]) {
                    return false;
                }
            }
            return true;
        });
        if (tsResult.length) {
            tokens = tokens.concat(tsResult);
        }
        return buildTokens(tokens);
        function buildTokens(tokens) {
            var _a;
            const builder = new node_1.SemanticTokensBuilder();
            for (const token of tokens.sort((a, b) => a[0] - b[0] === 0 ? a[1] - b[1] : a[0] - b[0])) {
                builder.push(token[0], token[1], token[2], token[3], (_a = token[4]) !== null && _a !== void 0 ? _a : 0);
            }
            return builder.build();
        }
        function getScriptSetupResult(sourceFile) {
            var _a;
            const result = [];
            const scriptSetupGen = sourceFile.getScriptSetupData();
            const scriptSetup = sourceFile.getDescriptor().scriptSetup;
            if (scriptSetupGen && scriptSetup) {
                const genData = scriptSetupGen;
                for (const label of genData.labels) {
                    const labelPos = document.positionAt(scriptSetup.loc.start + label.label.start);
                    result.push([labelPos.line, labelPos.character, label.label.end - label.label.start + 1, (_a = tokenTypes.get('refLabel')) !== null && _a !== void 0 ? _a : -1, undefined]);
                    // for (const binary of label.binarys) {
                    // 	for (const _var of binary.vars) {
                    // 		const varPos = document.positionAt(scriptSetup.loc.start + _var.start);
                    // 		result.push([varPos.line, varPos.character, _var.end - _var.start, tokenTypes.get('refVariable') ?? -1, undefined]);
                    // 		for (const reference of _var.references) {
                    // 			const referencePos = document.positionAt(scriptSetup.loc.start + reference.start);
                    // 			result.push([referencePos.line, referencePos.character, reference.end - reference.start, tokenTypes.get('refVariable') ?? -1, undefined]);
                    // 		}
                    // 	}
                    // }
                }
            }
            return result;
        }
        function getTsResult(sourceFile) {
            const result = [];
            for (const sourceMap of sourceFile.getTsSourceMaps()) {
                for (const maped of sourceMap) {
                    if (!maped.data.capabilities.semanticTokens)
                        continue;
                    if (offsetRange && maped.sourceRange.end < offsetRange.start)
                        continue;
                    if (offsetRange && maped.sourceRange.start > offsetRange.end)
                        continue;
                    const tsRange = {
                        start: sourceMap.mappedDocument.positionAt(maped.mappedRange.start),
                        end: sourceMap.mappedDocument.positionAt(maped.mappedRange.end),
                    };
                    const tokens = tsLanguageService.getDocumentSemanticTokens(sourceMap.mappedDocument.uri, tsRange, cancle);
                    if (!tokens)
                        continue;
                    for (const token of tokens) {
                        const tsStart = sourceMap.mappedDocument.offsetAt({ line: token[0], character: token[1] });
                        const tsEnd = sourceMap.mappedDocument.offsetAt({ line: token[0], character: token[1] + token[2] });
                        const vueRange = sourceMap.getSourceRange2(tsStart, tsEnd);
                        if (!(vueRange === null || vueRange === void 0 ? void 0 : vueRange.data.capabilities.semanticTokens))
                            continue;
                        const vuePos = document.positionAt(vueRange.start);
                        result.push([vuePos.line, vuePos.character, vueRange.end - vueRange.start, token[3], token[4]]);
                    }
                }
            }
            return result;
        }
        function getHtmlResult(sourceFile) {
            var _a;
            const result = [];
            for (const sourceMap of [...sourceFile.getHtmlSourceMaps(), ...sourceFile.getPugSourceMaps()]) {
                let start = offsetRange.start;
                let end = offsetRange.end;
                for (const mapping of sourceMap) {
                    const _start = mapping.sourceRange.start;
                    const _end = mapping.sourceRange.end;
                    if (_start >= offsetRange.start && _start < start) {
                        start = _start;
                    }
                    if (_end <= offsetRange.end && _end > end) {
                        end = _end;
                    }
                }
                const docText = sourceMap.mappedDocument.getText();
                const scanner = sourceMap.language === 'html'
                    ? languageServices.html.createScanner(docText, start)
                    : languageServices.pug.createScanner(sourceMap.pugDocument, start);
                if (!scanner)
                    continue;
                let token = scanner.scan();
                while (token !== html.TokenType.EOS && scanner.getTokenEnd() <= end) {
                    if (token === html.TokenType.StartTag || token === html.TokenType.EndTag) {
                        const tokenOffset = scanner.getTokenOffset();
                        const tokenLength = scanner.getTokenLength();
                        const tokenText = docText.substr(tokenOffset, tokenLength);
                        if (components.has(tokenText)) {
                            const vueRange = sourceMap.getSourceRange2(tokenOffset);
                            if (vueRange) {
                                const vueOffset = vueRange.start;
                                const vuePos = sourceMap.sourceDocument.positionAt(vueOffset);
                                result.push([vuePos.line, vuePos.character, tokenLength, (_a = tokenTypes.get('componentTag')) !== null && _a !== void 0 ? _a : -1, undefined]);
                            }
                        }
                    }
                    token = scanner.scan();
                }
            }
            return result;
        }
    };
}
exports.register = register;
//# sourceMappingURL=semanticTokens.js.map