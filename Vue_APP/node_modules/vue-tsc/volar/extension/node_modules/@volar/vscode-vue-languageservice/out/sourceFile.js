"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSourceFile = exports.defaultLanguages = void 0;
const prettyhtml = require("@starptech/prettyhtml");
const shared_1 = require("@volar/shared");
const vueSfc = require("@vue/compiler-sfc");
const reactivity_1 = require("@vue/reactivity");
const shared_2 = require("@vue/shared");
const css = require("vscode-css-languageservice");
const node_1 = require("vscode-languageserver/node");
const dedupe = require("./utils/dedupe");
const languageServices = require("./utils/languageServices");
const string_1 = require("./utils/string");
const main_1 = require("./virtuals/main");
const script_1 = require("./virtuals/script");
const script_raw_1 = require("./virtuals/script.raw");
const styles_raw_1 = require("./virtuals/styles.raw");
const template_1 = require("./virtuals/template");
const template_raw_1 = require("./virtuals/template.raw");
exports.defaultLanguages = {
    template: 'html',
    script: 'js',
    style: 'css',
};
function createSourceFile(initialDocument, tsLanguageService, ts, styleMode) {
    // sources
    const tsProjectVersion = reactivity_1.ref();
    const vueDoc = reactivity_1.ref(initialDocument);
    const vueUri = vueDoc.value.uri;
    const descriptor = reactivity_1.reactive({
        template: null,
        script: null,
        scriptSetup: null,
        styles: [],
        customBlocks: [],
    });
    const lastUpdateChanged = {
        template: false,
        script: false,
        scriptSetup: false,
    };
    const templateScriptData = reactivity_1.reactive({
        projectVersion: undefined,
        context: [],
        components: [],
        props: [],
        setupReturns: [],
        htmlElements: [],
        componentItems: [],
        htmlElementItems: [],
    });
    const vueHtmlDocument = reactivity_1.computed(() => {
        return languageServices.html.parseHTMLDocument(vueDoc.value);
    });
    const sfcErrors = reactivity_1.ref([]);
    // virtual scripts
    const _virtualStyles = styles_raw_1.useStylesRaw(ts, tsLanguageService, untrack(() => vueDoc.value), reactivity_1.computed(() => descriptor.styles), styleMode);
    const virtualTemplateRaw = template_raw_1.useTemplateRaw(untrack(() => vueDoc.value), reactivity_1.computed(() => descriptor.template));
    const templateData = reactivity_1.computed(() => {
        if (virtualTemplateRaw.pugDocument.value) {
            const pugDoc = virtualTemplateRaw.pugDocument.value;
            return {
                html: pugDoc.htmlCode,
                htmlToTemplate: (htmlStart, htmlEnd) => {
                    const pugRange = pugDoc.sourceMap.getSourceRange2(htmlStart, htmlEnd);
                    if (pugRange) {
                        return pugRange.start;
                    }
                },
            };
        }
        if (descriptor.template) {
            return {
                html: descriptor.template.content,
            };
        }
    });
    const virtualTemplateGen = template_1.useTemplateScript(untrack(() => vueDoc.value), reactivity_1.computed(() => descriptor.template), templateScriptData, _virtualStyles.textDocuments, _virtualStyles.sourceMaps, templateData);
    const virtualStyles = {
        textDocuments: reactivity_1.computed(() => [virtualTemplateGen.cssTextDocument.value, ..._virtualStyles.textDocuments.value].filter(shared_1.notEmpty)),
        sourceMaps: reactivity_1.computed(() => [virtualTemplateGen.cssSourceMap.value, ..._virtualStyles.sourceMaps.value].filter(shared_1.notEmpty)),
    };
    const virtualScriptGen = script_1.useScriptSetupGen(ts, vueDoc, reactivity_1.computed(() => descriptor.script), reactivity_1.computed(() => descriptor.scriptSetup), reactivity_1.computed(() => { var _a; return (_a = templateData.value) === null || _a === void 0 ? void 0 : _a.html; }));
    const virtualScriptRaw = script_raw_1.useScriptFormat(untrack(() => vueDoc.value), reactivity_1.computed(() => descriptor.script));
    const virtualScriptSetupRaw = script_raw_1.useScriptFormat(untrack(() => vueDoc.value), reactivity_1.computed(() => descriptor.scriptSetup));
    const virtualScriptMain = main_1.useScriptMain(untrack(() => vueDoc.value), reactivity_1.computed(() => descriptor.script), reactivity_1.computed(() => descriptor.scriptSetup), reactivity_1.computed(() => descriptor.template));
    // map / set
    const tsSourceMaps = reactivity_1.computed(() => {
        const result = [
            virtualScriptGen.sourceMap.value,
            virtualScriptGen.sourceMapForSuggestion.value,
            virtualScriptGen.sourceMapForTemplate.value,
            virtualScriptMain.sourceMap.value,
            virtualTemplateGen.sourceMap.value,
        ].filter(shared_1.notEmpty);
        return result;
    });
    const tsDocuments = reactivity_1.computed(() => {
        const docs = new Map();
        docs.set(virtualScriptMain.textDocument.value.uri, virtualScriptMain.textDocument.value);
        if (virtualScriptGen.textDocument.value)
            docs.set(virtualScriptGen.textDocument.value.uri, virtualScriptGen.textDocument.value);
        if (virtualScriptGen.textDocumentForSuggestion.value)
            docs.set(virtualScriptGen.textDocumentForSuggestion.value.uri, virtualScriptGen.textDocumentForSuggestion.value);
        if (virtualScriptGen.textDocumentForTemplate.value)
            docs.set(virtualScriptGen.textDocumentForTemplate.value.uri, virtualScriptGen.textDocumentForTemplate.value);
        if (virtualTemplateGen.textDocument.value)
            docs.set(virtualTemplateGen.textDocument.value.uri, virtualTemplateGen.textDocument.value);
        return docs;
    });
    update(initialDocument);
    // getters
    const getComponentCompletionData = useComponentCompletionData();
    const getDiagnostics = useDiagnostics();
    return {
        uri: vueUri,
        getTextDocument: untrack(() => vueDoc.value),
        update: untrack(update),
        updateTemplateScript: untrack(updateTemplateScript),
        getComponentCompletionData: untrack(getComponentCompletionData),
        getDiagnostics: untrack(getDiagnostics),
        getTsSourceMaps: untrack(() => tsSourceMaps.value),
        getMainTsDoc: untrack(() => virtualScriptMain.textDocument.value),
        getCssSourceMaps: untrack(() => virtualStyles.sourceMaps.value),
        getHtmlSourceMaps: untrack(() => virtualTemplateRaw.htmlSourceMap.value ? [virtualTemplateRaw.htmlSourceMap.value] : []),
        getPugSourceMaps: untrack(() => virtualTemplateRaw.pugSourceMap.value ? [virtualTemplateRaw.pugSourceMap.value] : []),
        getTemplateScriptData: untrack(() => templateScriptData),
        getTeleports: untrack(() => [
            virtualTemplateGen.teleportSourceMap.value,
            virtualScriptGen.teleportSourceMap.value,
        ].filter(shared_1.notEmpty)),
        getDescriptor: untrack(() => descriptor),
        getVueHtmlDocument: untrack(() => vueHtmlDocument.value),
        getTsDocuments: untrack(() => tsDocuments.value),
        getVirtualScript: untrack(() => ({
            document: virtualScriptGen.textDocument.value,
            sourceMap: virtualScriptGen.sourceMap.value,
        })),
        getScriptSetupData: untrack(() => virtualScriptGen.scriptSetupAst.value),
        getScriptsRaw: untrack(() => ({
            documents: [virtualScriptRaw.textDocument.value, virtualScriptSetupRaw.textDocument.value].filter(shared_1.notEmpty),
            sourceMaps: [virtualScriptRaw.sourceMap.value, virtualScriptSetupRaw.sourceMap.value].filter(shared_1.notEmpty),
        })),
        getTemplateScriptFormat: untrack(() => ({
            document: virtualTemplateGen.textDocumentForFormatting.value,
            sourceMap: virtualTemplateGen.sourceMapForFormatting.value,
        })),
    };
    function update(newVueDocument) {
        var _a, _b, _c, _d;
        const parsedSfc = vueSfc.parse(newVueDocument.getText(), { sourceMap: false });
        const newDescriptor = parsedSfc.descriptor;
        const versionsBeforeUpdate = [
            (_a = virtualScriptGen.textDocument.value) === null || _a === void 0 ? void 0 : _a.version,
            (_b = virtualTemplateGen.textDocument.value) === null || _b === void 0 ? void 0 : _b.version,
        ];
        updateSfcErrors();
        updateTemplate(newDescriptor);
        updateScript(newDescriptor);
        updateScriptSetup(newDescriptor);
        updateStyles(newDescriptor);
        updateCustomBlocks(newDescriptor);
        virtualTemplateGen.update(); // TODO
        if (newVueDocument.getText() !== vueDoc.value.getText()) {
            vueDoc.value = newVueDocument;
        }
        const versionsAfterUpdate = [
            (_c = virtualScriptGen.textDocument.value) === null || _c === void 0 ? void 0 : _c.version,
            (_d = virtualTemplateGen.textDocument.value) === null || _d === void 0 ? void 0 : _d.version,
        ];
        return {
            scriptUpdated: versionsBeforeUpdate[0] !== versionsAfterUpdate[0],
            templateScriptUpdated: versionsBeforeUpdate[1] !== versionsAfterUpdate[1],
        };
        function updateSfcErrors() {
            const errors = [];
            for (const error of parsedSfc.errors) {
                if ('code' in error && error.loc) {
                    const diag = node_1.Diagnostic.create(node_1.Range.create(error.loc.start.line - 1, error.loc.start.column - 1, error.loc.end.line - 1, error.loc.end.column - 1), error.message, node_1.DiagnosticSeverity.Error, error.code, 'vue');
                    errors.push(diag);
                }
            }
            sfcErrors.value = errors;
        }
        function updateTemplate(newDescriptor) {
            var _a, _b;
            const newData = newDescriptor.template ? {
                lang: (_a = newDescriptor.template.lang) !== null && _a !== void 0 ? _a : exports.defaultLanguages.template,
                content: newDescriptor.template.content,
                loc: {
                    start: newDescriptor.template.loc.start.offset,
                    end: newDescriptor.template.loc.end.offset,
                },
            } : null;
            lastUpdateChanged.template = ((_b = descriptor.template) === null || _b === void 0 ? void 0 : _b.content) !== (newData === null || newData === void 0 ? void 0 : newData.content);
            if (descriptor.template && newData) {
                descriptor.template.lang = newData.lang;
                descriptor.template.content = newData.content;
                descriptor.template.loc.start = newData.loc.start;
                descriptor.template.loc.end = newData.loc.end;
            }
            else {
                descriptor.template = newData;
            }
        }
        function updateScript(newDescriptor) {
            var _a, _b;
            const newData = newDescriptor.script ? {
                src: newDescriptor.script.src,
                lang: (_a = newDescriptor.script.lang) !== null && _a !== void 0 ? _a : exports.defaultLanguages.script,
                content: newDescriptor.script.content,
                loc: {
                    start: newDescriptor.script.loc.start.offset,
                    end: newDescriptor.script.loc.end.offset,
                },
            } : null;
            lastUpdateChanged.script = ((_b = descriptor.script) === null || _b === void 0 ? void 0 : _b.content) !== (newData === null || newData === void 0 ? void 0 : newData.content);
            if (descriptor.script && newData) {
                descriptor.script.src = newData.src;
                descriptor.script.lang = newData.lang;
                descriptor.script.content = newData.content;
                descriptor.script.loc.start = newData.loc.start;
                descriptor.script.loc.end = newData.loc.end;
            }
            else {
                descriptor.script = newData;
            }
        }
        function updateScriptSetup(newDescriptor) {
            var _a, _b;
            const newData = newDescriptor.scriptSetup ? {
                lang: (_a = newDescriptor.scriptSetup.lang) !== null && _a !== void 0 ? _a : 'js',
                content: newDescriptor.scriptSetup.content,
                loc: {
                    start: newDescriptor.scriptSetup.loc.start.offset,
                    end: newDescriptor.scriptSetup.loc.end.offset,
                },
            } : null;
            lastUpdateChanged.scriptSetup = ((_b = descriptor.scriptSetup) === null || _b === void 0 ? void 0 : _b.content) !== (newData === null || newData === void 0 ? void 0 : newData.content);
            if (descriptor.scriptSetup && newData) {
                descriptor.scriptSetup.lang = newData.lang;
                descriptor.scriptSetup.content = newData.content;
                descriptor.scriptSetup.loc.start = newData.loc.start;
                descriptor.scriptSetup.loc.end = newData.loc.end;
            }
            else {
                descriptor.scriptSetup = newData;
            }
        }
        function updateStyles(newDescriptor) {
            var _a;
            for (let i = 0; i < newDescriptor.styles.length; i++) {
                const style = newDescriptor.styles[i];
                const newData = {
                    lang: (_a = style.lang) !== null && _a !== void 0 ? _a : exports.defaultLanguages.style,
                    content: style.content,
                    loc: {
                        start: style.loc.start.offset,
                        end: style.loc.end.offset,
                    },
                    module: !!style.module,
                    scoped: !!style.scoped,
                };
                if (descriptor.styles.length > i) {
                    descriptor.styles[i].lang = newData.lang;
                    descriptor.styles[i].content = newData.content;
                    descriptor.styles[i].loc.start = newData.loc.start;
                    descriptor.styles[i].loc.end = newData.loc.end;
                    descriptor.styles[i].module = newData.module;
                    descriptor.styles[i].scoped = newData.scoped;
                }
                else {
                    descriptor.styles.push(newData);
                }
            }
            while (descriptor.styles.length > newDescriptor.styles.length) {
                descriptor.styles.pop();
            }
        }
        function updateCustomBlocks(newDescriptor) {
            var _a;
            for (let i = 0; i < newDescriptor.customBlocks.length; i++) {
                const block = newDescriptor.customBlocks[i];
                const newData = {
                    type: block.type,
                    lang: (_a = block.lang) !== null && _a !== void 0 ? _a : '',
                    content: block.content,
                    loc: {
                        start: block.loc.start.offset,
                        end: block.loc.end.offset,
                    },
                };
                if (descriptor.customBlocks.length > i) {
                    descriptor.customBlocks[i].type = newData.type;
                    descriptor.customBlocks[i].lang = newData.lang;
                    descriptor.customBlocks[i].content = newData.content;
                    descriptor.customBlocks[i].loc.start = newData.loc.start;
                    descriptor.customBlocks[i].loc.end = newData.loc.end;
                }
                else {
                    descriptor.customBlocks.push(newData);
                }
            }
            while (descriptor.customBlocks.length > newDescriptor.customBlocks.length) {
                descriptor.customBlocks.pop();
            }
        }
    }
    function updateTemplateScript() {
        var _a, _b, _c, _d;
        if (templateScriptData.projectVersion === ((_b = (_a = tsLanguageService.host).getProjectVersion) === null || _b === void 0 ? void 0 : _b.call(_a))) {
            return false;
        }
        templateScriptData.projectVersion = (_d = (_c = tsLanguageService.host).getProjectVersion) === null || _d === void 0 ? void 0 : _d.call(_c);
        const doc = virtualScriptMain.textDocument.value;
        const docText = doc.getText();
        const context = docText.indexOf(string_1.SearchTexts.Context) >= 0 ? tsLanguageService.doComplete(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.Context))) : [];
        const components = docText.indexOf(string_1.SearchTexts.Components) >= 0 ? tsLanguageService.doComplete(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.Components))) : [];
        const props = docText.indexOf(string_1.SearchTexts.Props) >= 0 ? tsLanguageService.doComplete(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.Props))) : [];
        const setupReturns = docText.indexOf(string_1.SearchTexts.SetupReturns) >= 0 ? tsLanguageService.doComplete(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.SetupReturns))) : [];
        const globalEls = docText.indexOf(string_1.SearchTexts.HtmlElements) >= 0 ? tsLanguageService.doComplete(doc.uri, doc.positionAt(doc.getText().indexOf(string_1.SearchTexts.HtmlElements))) : [];
        const contextNames = context.map(entry => entry.data.name);
        const componentNames = components.map(entry => entry.data.name);
        const propNames = props.map(entry => entry.data.name);
        const setupReturnNames = setupReturns.map(entry => entry.data.name);
        const htmlElementNames = globalEls.map(entry => entry.data.name);
        if (shared_1.eqSet(new Set(contextNames), new Set(templateScriptData.context))
            && shared_1.eqSet(new Set(componentNames), new Set(templateScriptData.components))
            && shared_1.eqSet(new Set(propNames), new Set(templateScriptData.props))
            && shared_1.eqSet(new Set(setupReturnNames), new Set(templateScriptData.setupReturns))
            && shared_1.eqSet(new Set(htmlElementNames), new Set(templateScriptData.htmlElements))) {
            return false;
        }
        templateScriptData.context = contextNames;
        templateScriptData.components = componentNames;
        templateScriptData.props = propNames;
        templateScriptData.setupReturns = setupReturnNames;
        templateScriptData.htmlElements = htmlElementNames;
        templateScriptData.componentItems = components;
        templateScriptData.htmlElementItems = globalEls;
        virtualTemplateGen.update(); // TODO
        return true;
    }
    function useDiagnostics() {
        const tsOptions = tsLanguageService.host.getCompilationSettings();
        const anyNoUnusedEnabled = tsOptions.noUnusedLocals || tsOptions.noUnusedParameters;
        const nonTs = [
            [useStylesValidation(reactivity_1.computed(() => virtualStyles.textDocuments.value)), 0, []],
            [useTemplateValidation(), 0, []],
            [useScriptExistValidation(), 0, []],
        ];
        let templateTs = [
            [useTemplateScriptValidation(1), 0, []],
            [useTemplateScriptValidation(2), 0, []],
            [useTemplateScriptValidation(3), 0, []],
        ];
        let scriptTs = [
            [useScriptValidation(virtualScriptGen.textDocument, 1), 0, []],
            [useScriptValidation(virtualScriptGen.textDocument, 2), 0, []],
            [useScriptValidation(reactivity_1.computed(() => { var _a; return (_a = virtualScriptGen.textDocumentForSuggestion.value) !== null && _a !== void 0 ? _a : virtualScriptGen.textDocument.value; }), 3), 0, []],
            // [useScriptValidation(virtualScriptGen.textDocument, 4), 0, []], // TODO: support cancel because it's very slow
            [useScriptValidation(reactivity_1.computed(() => anyNoUnusedEnabled ? virtualScriptGen.textDocumentForSuggestion.value : undefined), 1, true), 0, []],
        ];
        return async (response, isCancel) => {
            var _a, _b;
            tsProjectVersion.value = (_b = (_a = tsLanguageService.host).getProjectVersion) === null || _b === void 0 ? void 0 : _b.call(_a);
            // sort by cost
            templateTs = templateTs.sort((a, b) => a[1] - b[1]);
            scriptTs = scriptTs.sort((a, b) => a[1] - b[1]);
            let all = [...nonTs];
            let mainTsErrorStart = all.length - 1;
            let mainTsErrorEnd = -1;
            const isScriptChanged = lastUpdateChanged.script || lastUpdateChanged.scriptSetup;
            if (isScriptChanged) {
                all = all.concat(scriptTs);
                mainTsErrorEnd = all.length - 1;
                all = all.concat(templateTs);
            }
            else {
                all = all.concat(templateTs);
                mainTsErrorEnd = all.length - 1;
                all = all.concat(scriptTs);
            }
            let isDirty = false;
            for (let i = 0; i < all.length; i++) {
                if (await (isCancel === null || isCancel === void 0 ? void 0 : isCancel()))
                    return;
                const startTime = Date.now();
                const diag = all[i];
                if (!isDirty) {
                    isDirty = isErrorsDirty(diag[2], diag[0].result.value);
                }
                diag[2] = diag[0].result.value;
                diag[1] = Date.now() - startTime;
                const newErrors = all
                    .slice(0, i + 1)
                    .map(diag => diag[0].result.value)
                    .flat()
                    .concat(sfcErrors.value);
                const oldErrors = all
                    .slice(i + 1)
                    .map(diag => i >= mainTsErrorStart && !isScriptChanged ? diag[0].cache.value : diag[2])
                    .flat();
                const isLast = i === all.length - 1;
                if (await (isCancel === null || isCancel === void 0 ? void 0 : isCancel()))
                    return;
                if (isLast
                    || (isDirty && (i < mainTsErrorStart
                        || i === mainTsErrorEnd
                        || oldErrors.length === 0))) {
                    isDirty = false;
                    response(dedupe.withDiagnostics(newErrors.concat(oldErrors)));
                }
            }
            function isErrorsDirty(oldErrors, newErrors) {
                return !shared_1.eqSet(errorsToKeys(oldErrors), errorsToKeys(newErrors));
            }
            function errorsToKeys(errors) {
                return new Set(errors.map(error => error.source
                    + ':' + error.code
                    + ':' + error.message));
            }
        };
        function useTemplateValidation() {
            const htmlErrors = reactivity_1.computed(() => {
                if (virtualTemplateRaw.textDocument.value && virtualTemplateRaw.htmlDocument.value) {
                    return getVueCompileErrors(virtualTemplateRaw.textDocument.value);
                }
                return [];
            });
            const pugErrors = reactivity_1.computed(() => {
                var _a, _b;
                const result = [];
                if (virtualTemplateRaw.textDocument.value && virtualTemplateRaw.pugDocument.value) {
                    const pugDoc = virtualTemplateRaw.pugDocument.value;
                    const astError = pugDoc.error;
                    if (astError) {
                        result.push({
                            code: astError.code,
                            message: astError.msg,
                            range: {
                                start: { line: astError.line, character: astError.column },
                                end: { line: astError.line, character: astError.column },
                            },
                        });
                    }
                    else {
                        const htmlDoc = pugDoc.sourceMap.mappedDocument;
                        const vueCompileErrors = getVueCompileErrors(htmlDoc);
                        for (const vueCompileError of vueCompileErrors) {
                            let pugRange = pugDoc.sourceMap.getSourceRange(vueCompileError.range.start, vueCompileError.range.end);
                            if (!pugRange) {
                                const pugStart = (_a = pugDoc.sourceMap.getSourceRange(vueCompileError.range.start, vueCompileError.range.start)) === null || _a === void 0 ? void 0 : _a.start;
                                const pugEnd = (_b = pugDoc.sourceMap.getSourceRange(vueCompileError.range.end, vueCompileError.range.end)) === null || _b === void 0 ? void 0 : _b.end;
                                if (pugStart && pugEnd) {
                                    pugRange = {
                                        start: pugStart,
                                        end: pugEnd,
                                    };
                                    // trim empty space
                                    const pugText = pugDoc.sourceMap.sourceDocument.getText(pugRange);
                                    const trimLength = pugText.length - pugText.trimEnd().length;
                                    if (trimLength) {
                                        pugRange.end = pugDoc.sourceMap.sourceDocument.positionAt(pugDoc.sourceMap.sourceDocument.offsetAt(pugEnd)
                                            - trimLength);
                                    }
                                }
                            }
                            if (pugRange) {
                                vueCompileError.range = pugRange;
                                result.push(vueCompileError);
                            }
                            else {
                                let htmlText = htmlDoc.getText(vueCompileError.range);
                                let errorText = '';
                                try {
                                    errorText += '\n```html\n' + prettyhtml(htmlText).contents.trim() + '\n```'; // may thorw
                                }
                                catch (error) {
                                    errorText += '\n```html\n' + htmlText.trim() + '\n```'; // may thorw
                                    errorText += '\n```json\n' + JSON.stringify(error, null, 2) + '\n```';
                                }
                                vueCompileError.message += errorText;
                                vueCompileError.range = {
                                    start: virtualTemplateRaw.textDocument.value.positionAt(0),
                                    end: virtualTemplateRaw.textDocument.value.positionAt(virtualTemplateRaw.textDocument.value.getText().length),
                                };
                                result.push(vueCompileError);
                            }
                        }
                    }
                }
                return result;
            });
            const htmlErrors_cache = reactivity_1.ref([]);
            const pugErrors_cache = reactivity_1.ref([]);
            const result = reactivity_1.computed(() => {
                htmlErrors_cache.value = htmlErrors.value;
                pugErrors_cache.value = pugErrors.value;
                return cacheWithSourceMap.value;
            });
            const cacheWithSourceMap = reactivity_1.computed(() => {
                if (!virtualTemplateRaw.textDocument.value)
                    return [];
                return [
                    ...toSourceDiags(htmlErrors.value, virtualTemplateRaw.textDocument.value.uri, virtualTemplateRaw.htmlSourceMap.value ? [virtualTemplateRaw.htmlSourceMap.value] : []),
                    ...toSourceDiags(pugErrors.value, virtualTemplateRaw.textDocument.value.uri, virtualTemplateRaw.pugSourceMap.value ? [virtualTemplateRaw.pugSourceMap.value] : []),
                ];
            });
            return {
                result,
                cache: cacheWithSourceMap,
            };
            function getVueCompileErrors(doc) {
                const result = [];
                try {
                    const templateResult = vueSfc.compileTemplate({
                        source: doc.getText(),
                        filename: shared_1.uriToFsPath(vueUri),
                        id: shared_1.uriToFsPath(vueUri),
                        compilerOptions: {
                            onError: err => {
                                if (!err.loc)
                                    return;
                                const diagnostic = {
                                    range: {
                                        start: doc.positionAt(err.loc.start.offset),
                                        end: doc.positionAt(err.loc.end.offset),
                                    },
                                    severity: node_1.DiagnosticSeverity.Error,
                                    code: err.code,
                                    source: 'vue',
                                    message: err.message,
                                };
                                result.push(diagnostic);
                            },
                        }
                    });
                    for (const err of templateResult.errors) {
                        if (typeof err !== 'object' || !err.loc)
                            continue;
                        const diagnostic = {
                            range: {
                                start: doc.positionAt(err.loc.start.offset),
                                end: doc.positionAt(err.loc.end.offset),
                            },
                            severity: node_1.DiagnosticSeverity.Error,
                            source: 'vue',
                            code: err.code,
                            message: err.message,
                        };
                        result.push(diagnostic);
                    }
                }
                catch (err) {
                    const diagnostic = {
                        range: {
                            start: doc.positionAt(0),
                            end: doc.positionAt(doc.getText().length),
                        },
                        severity: node_1.DiagnosticSeverity.Error,
                        code: err.code,
                        source: 'vue',
                        message: err.message,
                    };
                    result.push(diagnostic);
                }
                return result;
            }
        }
        function useStylesValidation(documents) {
            const errors = reactivity_1.computed(() => {
                let result = new Map();
                for (const { textDocument, stylesheet } of documents.value) {
                    const cssLanguageService = languageServices.getCssLanguageService(textDocument.languageId);
                    if (!cssLanguageService || !stylesheet)
                        continue;
                    const errs = cssLanguageService.doValidation(textDocument, stylesheet);
                    if (errs)
                        result.set(textDocument.uri, errs);
                }
                return result;
            });
            const errors_cache = reactivity_1.ref(new Map());
            const result = reactivity_1.computed(() => {
                errors_cache.value = errors.value;
                return cacheWithSourceMap.value;
            });
            const cacheWithSourceMap = reactivity_1.computed(() => {
                let result = [];
                for (const [uri, errs] of errors_cache.value) {
                    result = result.concat(toSourceDiags(errs, uri, virtualStyles.sourceMaps.value));
                }
                return result;
            });
            return {
                result,
                cache: cacheWithSourceMap,
            };
        }
        function useScriptExistValidation() {
            const result = reactivity_1.computed(() => {
                const diags = [];
                if (virtualScriptGen.textDocument.value
                    && !tsLanguageService.getTextDocument2(virtualScriptGen.textDocument.value.uri)) {
                    for (const script of [descriptor.script, descriptor.scriptSetup]) {
                        if (!script)
                            continue;
                        diags.push(node_1.Diagnostic.create({
                            start: vueDoc.value.positionAt(script.loc.start),
                            end: vueDoc.value.positionAt(script.loc.end),
                        }, 'services are not working for this script block because virtual file is not found in TS server, maybe try to add lang="ts" to <script> or add `"allowJs": true` to tsconfig.json', node_1.DiagnosticSeverity.Warning, undefined, 'volar'));
                    }
                }
                return diags;
            });
            return {
                result,
                cache: result,
            };
        }
        function useScriptValidation(document, mode, onlyUnusedCheck = false) {
            const errors = reactivity_1.computed(() => {
                if (mode === 1) { // watching
                    tsProjectVersion.value;
                }
                const doc = document.value;
                if (!doc)
                    return [];
                if (mode === 1) {
                    return tsLanguageService.doValidation(doc.uri, { semantic: true });
                }
                else if (mode === 2) {
                    return tsLanguageService.doValidation(doc.uri, { syntactic: true });
                }
                else if (mode === 3) {
                    return tsLanguageService.doValidation(doc.uri, { suggestion: true });
                }
                else if (mode === 4) {
                    return tsLanguageService.doValidation(doc.uri, { declaration: true });
                }
                return [];
            });
            const errors_cache = reactivity_1.ref([]);
            const result = reactivity_1.computed(() => {
                errors_cache.value = errors.value;
                return cacheWithSourceMap.value;
            });
            const cacheWithSourceMap = reactivity_1.computed(() => {
                const doc = document.value;
                if (!doc)
                    return [];
                let result = toTsSourceDiags(errors_cache.value, doc.uri, tsSourceMaps.value);
                if (onlyUnusedCheck) {
                    result = result.filter(error => { var _a; return (_a = error.tags) === null || _a === void 0 ? void 0 : _a.includes(node_1.DiagnosticTag.Unnecessary); });
                }
                return result;
            });
            return {
                result,
                cache: cacheWithSourceMap,
            };
        }
        function useTemplateScriptValidation(mode) {
            const errors_1 = reactivity_1.computed(() => {
                if (mode === 1) { // watching
                    tsProjectVersion.value;
                }
                const doc = virtualTemplateGen.textDocument.value;
                if (!doc)
                    return [];
                if (mode === 1) {
                    return tsLanguageService.doValidation(doc.uri, { semantic: true });
                }
                else if (mode === 2) {
                    return tsLanguageService.doValidation(doc.uri, { syntactic: true });
                }
                else if (mode === 3) {
                    return tsLanguageService.doValidation(doc.uri, { suggestion: true });
                }
                else if (mode === 4) {
                    return tsLanguageService.doValidation(doc.uri, { declaration: true });
                }
                return [];
            });
            const errors_2 = reactivity_1.computed(() => {
                const result = [];
                if (!virtualTemplateGen.textDocument.value
                    || !virtualTemplateGen.teleportSourceMap.value
                    || !virtualScriptGen.textDocument.value)
                    return result;
                for (const diag of errors_1.value) {
                    const spanText = virtualTemplateGen.textDocument.value.getText(diag.range);
                    if (!templateScriptData.setupReturns.includes(spanText))
                        continue;
                    const propRights = virtualTemplateGen.teleportSourceMap.value.getMappedRanges(diag.range.start, diag.range.end);
                    for (const propRight of propRights) {
                        if (propRight.data.isAdditionalReference)
                            continue;
                        const definitions = tsLanguageService.findDefinition(virtualTemplateGen.textDocument.value.uri, propRight.start);
                        for (const definition of definitions) {
                            if (definition.targetUri !== virtualScriptGen.textDocument.value.uri)
                                continue;
                            result.push({
                                ...diag,
                                range: definition.targetSelectionRange,
                            });
                        }
                    }
                }
                return result;
            });
            const errors_1_cache = reactivity_1.ref([]);
            const errors_2_cache = reactivity_1.ref([]);
            const result = reactivity_1.computed(() => {
                errors_1_cache.value = errors_1.value;
                errors_2_cache.value = errors_2.value;
                return cacheWithSourceMap.value;
            });
            const cacheWithSourceMap = reactivity_1.computed(() => {
                const result_1 = virtualTemplateGen.textDocument.value ? toTsSourceDiags(errors_1_cache.value, virtualTemplateGen.textDocument.value.uri, tsSourceMaps.value) : [];
                const result_2 = virtualScriptGen.textDocument.value ? toTsSourceDiags(errors_2_cache.value, virtualScriptGen.textDocument.value.uri, tsSourceMaps.value) : [];
                return [...result_1, ...result_2];
            });
            return {
                result,
                cache: cacheWithSourceMap,
            };
        }
        function toSourceDiags(errors, virtualScriptUri, sourceMaps) {
            const result = [];
            for (const error of errors) {
                if (css.Diagnostic.is(error) || node_1.Diagnostic.is(error)) {
                    for (const sourceMap of sourceMaps) {
                        if (sourceMap.mappedDocument.uri !== virtualScriptUri)
                            continue;
                        const vueRange = sourceMap.getSourceRange(error.range.start, error.range.end);
                        if (!vueRange)
                            continue;
                        result.push({
                            ...error,
                            range: vueRange,
                        });
                    }
                }
            }
            return result;
        }
        function toTsSourceDiags(errors, virtualScriptUri, sourceMaps) {
            const result = [];
            for (const error of errors) {
                let found = false;
                for (const sourceMap of sourceMaps) {
                    if (sourceMap.mappedDocument.uri !== virtualScriptUri)
                        continue;
                    const vueRange = sourceMap.getSourceRange(error.range.start, error.range.end);
                    if (!vueRange || !vueRange.data.capabilities.diagnostic)
                        continue;
                    result.push({
                        ...error,
                        range: vueRange,
                    });
                    found = true;
                }
                if (!found) { // patching for ref sugar
                    for (const sourceMap of sourceMaps) {
                        if (sourceMap.mappedDocument.uri !== virtualScriptUri)
                            continue;
                        const vueStartRange = sourceMap.getSourceRange(error.range.start);
                        if (!vueStartRange || !vueStartRange.data.capabilities.diagnostic)
                            continue;
                        const vueEndRange = sourceMap.getSourceRange(error.range.end);
                        if (!vueEndRange || !vueEndRange.data.capabilities.diagnostic)
                            continue;
                        result.push({
                            ...error,
                            range: {
                                start: vueStartRange.start,
                                end: vueEndRange.start,
                            },
                        });
                    }
                }
            }
            return result;
        }
    }
    function useComponentCompletionData() {
        const result = reactivity_1.computed(() => {
            { // watching
                tsProjectVersion.value;
            }
            const data = new Map();
            if (virtualTemplateGen.textDocument.value && virtualTemplateRaw.textDocument.value) {
                const doc = virtualTemplateGen.textDocument.value;
                const text = doc.getText();
                for (const tag of [...templateScriptData.componentItems, ...templateScriptData.htmlElementItems]) {
                    const tagName = tag.data.name;
                    let bind = [];
                    let on = [];
                    let slot = [];
                    {
                        const searchText = `__VLS_componentPropsBase['${tagName}']['`;
                        let offset = text.indexOf(searchText);
                        if (offset >= 0) {
                            offset += searchText.length;
                            bind = tsLanguageService.doComplete(doc.uri, doc.positionAt(offset));
                        }
                    }
                    {
                        const searchText = `__VLS_componentEmits['${tagName}']('`;
                        let offset = text.indexOf(searchText);
                        if (offset >= 0) {
                            offset += searchText.length;
                            on = tsLanguageService.doComplete(doc.uri, doc.positionAt(offset));
                        }
                    }
                    {
                        const searchText = `__VLS_components['${tagName}'].__VLS_slots['`;
                        let offset = text.indexOf(searchText);
                        if (offset >= 0) {
                            offset += searchText.length;
                            slot = tsLanguageService.doComplete(doc.uri, doc.positionAt(offset));
                        }
                    }
                    data.set(tagName, { item: tag, bind, on, slot });
                    data.set(shared_2.hyphenate(tagName), { item: tag, bind, on, slot });
                }
                const globalBind = tsLanguageService.doComplete(doc.uri, doc.positionAt(doc.getText().indexOf(string_1.SearchTexts.GlobalAttrs)));
                data.set('*', { item: undefined, bind: globalBind, on: [], slot: [] });
            }
            return data;
        });
        return () => {
            var _a, _b;
            tsProjectVersion.value = (_b = (_a = tsLanguageService.host).getProjectVersion) === null || _b === void 0 ? void 0 : _b.call(_a);
            return result.value;
        };
    }
    function untrack(source) {
        return ((...args) => {
            reactivity_1.pauseTracking();
            const result = source(...args);
            reactivity_1.resetTracking();
            return result;
        });
    }
}
exports.createSourceFile = createSourceFile;
//# sourceMappingURL=sourceFile.js.map