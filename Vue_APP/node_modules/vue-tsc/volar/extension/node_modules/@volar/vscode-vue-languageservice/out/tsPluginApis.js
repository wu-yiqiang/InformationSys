"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const shared_1 = require("@volar/shared");
function register({ mapper, tsLanguageService }) {
    return {
        getCompletionsAtPosition,
        getDefinitionAtPosition,
        getDefinitionAndBoundSpan,
        getTypeDefinitionAtPosition,
        getImplementationAtPosition,
        findRenameLocations,
        getReferencesAtPosition,
        findReferences,
    };
    // apis
    function getCompletionsAtPosition(fileName, position, options) {
        const info = tsLanguageService.raw.getCompletionsAtPosition(fileName, position, options);
        if (!info)
            return;
        return {
            ...info,
            entries: info.entries.filter(entry => entry.name.indexOf('__VLS_') === -1),
        };
    }
    function getReferencesAtPosition(fileName, position) {
        return findLocations(fileName, position, 'references');
    }
    function getDefinitionAtPosition(fileName, position) {
        return findLocations(fileName, position, 'definition');
    }
    function getTypeDefinitionAtPosition(fileName, position) {
        return findLocations(fileName, position, 'typeDefinition');
    }
    function getImplementationAtPosition(fileName, position) {
        return findLocations(fileName, position, 'implementation');
    }
    function findRenameLocations(fileName, position) {
        return findLocations(fileName, position, 'rename');
    }
    function findLocations(fileName, position, mode, findInStrings = false, findInComments = false, providePrefixAndSuffixTextForRename) {
        const loopChecker = new Set();
        let symbols = [];
        withTeleports(fileName, position);
        return symbols.map(transformDocumentSpanLike).filter(shared_1.notEmpty);
        function withTeleports(fileName, position) {
            const _symbols = mode === 'definition' ? tsLanguageService.raw.getDefinitionAtPosition(fileName, position)
                : mode === 'typeDefinition' ? tsLanguageService.raw.getTypeDefinitionAtPosition(fileName, position)
                    : mode === 'references' ? tsLanguageService.raw.getReferencesAtPosition(fileName, position)
                        : mode === 'implementation' ? tsLanguageService.raw.getImplementationAtPosition(fileName, position)
                            : mode === 'rename' ? tsLanguageService.raw.findRenameLocations(fileName, position, findInStrings, findInComments, providePrefixAndSuffixTextForRename)
                                : undefined;
            if (!_symbols)
                return;
            symbols = symbols.concat(_symbols);
            for (const ref of _symbols) {
                loopChecker.add(ref.fileName + ':' + ref.textSpan.start);
                for (const teleRange of mapper.ts.teleports2(ref.fileName, ref.textSpan.start, ref.textSpan.start + ref.textSpan.length)) {
                    if ((mode === 'definition' || mode === 'typeDefinition' || mode === 'implementation') && !teleRange.sideData.capabilities.definitions)
                        continue;
                    if ((mode === 'references') && !teleRange.sideData.capabilities.references)
                        continue;
                    if ((mode === 'rename') && !teleRange.sideData.capabilities.rename)
                        continue;
                    if (loopChecker.has(ref.fileName + ':' + teleRange.start))
                        continue;
                    withTeleports(ref.fileName, teleRange.start);
                }
            }
        }
    }
    function getDefinitionAndBoundSpan(fileName, position) {
        const loopChecker = new Set();
        let textSpan;
        let symbols = [];
        withTeleports(fileName, position);
        if (!textSpan)
            return;
        return {
            textSpan: textSpan,
            definitions: symbols === null || symbols === void 0 ? void 0 : symbols.map(transformDocumentSpanLike).filter(shared_1.notEmpty),
        };
        function withTeleports(fileName, position) {
            const _symbols = tsLanguageService.raw.getDefinitionAndBoundSpan(fileName, position);
            if (!_symbols)
                return;
            if (!textSpan) {
                textSpan = _symbols.textSpan;
            }
            if (!_symbols.definitions)
                return;
            symbols = symbols.concat(_symbols.definitions);
            for (const ref of _symbols.definitions) {
                loopChecker.add(ref.fileName + ':' + ref.textSpan.start);
                for (const teleRange of mapper.ts.teleports2(ref.fileName, ref.textSpan.start, ref.textSpan.start + ref.textSpan.length)) {
                    if (!teleRange.sideData.capabilities.definitions)
                        continue;
                    if (loopChecker.has(ref.fileName + ':' + teleRange.start))
                        continue;
                    withTeleports(ref.fileName, teleRange.start);
                }
            }
        }
    }
    function findReferences(fileName, position) {
        const loopChecker = new Set();
        let symbols = [];
        withTeleports(fileName, position);
        return symbols.map(transformReferencedSymbol).filter(shared_1.notEmpty);
        function withTeleports(fileName, position) {
            const _symbols = tsLanguageService.raw.findReferences(fileName, position);
            if (!_symbols)
                return;
            symbols = symbols.concat(_symbols);
            for (const symbol of _symbols) {
                for (const ref of symbol.references) {
                    loopChecker.add(ref.fileName + ':' + ref.textSpan.start);
                    for (const teleRange of mapper.ts.teleports2(ref.fileName, ref.textSpan.start, ref.textSpan.start + ref.textSpan.length)) {
                        if (!teleRange.sideData.capabilities.references)
                            continue;
                        if (loopChecker.has(ref.fileName + ':' + teleRange.start))
                            continue;
                        withTeleports(ref.fileName, teleRange.start);
                    }
                }
            }
        }
    }
    // transforms
    function transformReferencedSymbol(symbol) {
        const definition = transformDocumentSpanLike(symbol.definition);
        const references = symbol.references.map(transformDocumentSpanLike).filter(shared_1.notEmpty);
        if (definition) {
            return {
                definition,
                references,
            };
        }
        else if (references.length) { // TODO: remove patching
            return {
                definition: {
                    ...symbol.definition,
                    fileName: references[0].fileName,
                    textSpan: references[0].textSpan,
                },
                references,
            };
        }
    }
    function transformDocumentSpanLike(documentSpan) {
        const textSpan = transformSpan(documentSpan.fileName, documentSpan.textSpan);
        if (!textSpan)
            return;
        const contextSpan = transformSpan(documentSpan.fileName, documentSpan.contextSpan);
        const originalTextSpan = transformSpan(documentSpan.originalFileName, documentSpan.originalTextSpan);
        const originalContextSpan = transformSpan(documentSpan.originalFileName, documentSpan.originalContextSpan);
        return {
            ...documentSpan,
            fileName: textSpan.fileName,
            textSpan: textSpan.textSpan,
            contextSpan: contextSpan === null || contextSpan === void 0 ? void 0 : contextSpan.textSpan,
            originalFileName: originalTextSpan === null || originalTextSpan === void 0 ? void 0 : originalTextSpan.fileName,
            originalTextSpan: originalTextSpan === null || originalTextSpan === void 0 ? void 0 : originalTextSpan.textSpan,
            originalContextSpan: originalContextSpan === null || originalContextSpan === void 0 ? void 0 : originalContextSpan.textSpan,
        };
    }
    function transformSpan(fileName, textSpan) {
        if (!fileName)
            return;
        if (!textSpan)
            return;
        for (const vueRange of mapper.ts.from2(fileName, textSpan.start, textSpan.start + textSpan.length)) {
            return {
                fileName: vueRange.fileName,
                textSpan: {
                    start: vueRange.start,
                    length: vueRange.end - vueRange.start,
                },
            };
        }
    }
}
exports.register = register;
//# sourceMappingURL=tsPluginApis.js.map