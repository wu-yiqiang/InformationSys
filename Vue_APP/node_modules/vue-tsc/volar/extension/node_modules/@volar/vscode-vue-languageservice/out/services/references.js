"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const dedupe = require("../utils/dedupe");
function register({ mapper }) {
    return (uri, position) => {
        const tsResult = onTs(uri, position);
        const cssResult = onCss(uri, position);
        return dedupe.withLocations([
            ...tsResult,
            ...cssResult,
        ]);
    };
    function onTs(uri, position) {
        const loopChecker = dedupe.createLocationSet();
        let tsResult = [];
        let vueResult = [];
        // vue -> ts
        for (const tsRange of mapper.ts.to(uri, position)) {
            if (!tsRange.data.capabilities.references)
                continue;
            withTeleports(tsRange.textDocument.uri, tsRange.start);
            function withTeleports(uri, position) {
                const tsLocs = tsRange.languageService.findReferences(uri, position);
                tsResult = tsResult.concat(tsLocs);
                for (const tsLoc of tsLocs) {
                    loopChecker.add({ uri: tsLoc.uri, range: tsLoc.range });
                    for (const teleRange of mapper.ts.teleports(tsLoc.uri, tsLoc.range.start, tsLoc.range.end)) {
                        if (!teleRange.sideData.capabilities.references)
                            continue;
                        if (loopChecker.has({ uri: tsLoc.uri, range: teleRange }))
                            continue;
                        withTeleports(tsLoc.uri, teleRange.start);
                    }
                }
            }
        }
        // ts -> vue
        for (const tsLoc of tsResult) {
            for (const vueRange of mapper.ts.from(tsLoc.uri, tsLoc.range.start, tsLoc.range.end)) {
                vueResult.push({
                    uri: vueRange.textDocument.uri,
                    range: vueRange,
                });
            }
        }
        return vueResult;
    }
    function onCss(uri, position) {
        let cssResult = [];
        let vueResult = [];
        // vue -> css
        for (const cssRange of mapper.css.to(uri, position)) {
            const cssLocs = cssRange.languageService.findReferences(cssRange.textDocument, cssRange.start, cssRange.stylesheet);
            cssResult = cssResult.concat(cssLocs);
        }
        // css -> vue
        for (const cssLoc of cssResult) {
            for (const vueRange of mapper.css.from(cssLoc.uri, cssLoc.range.start, cssLoc.range.end)) {
                vueResult.push({
                    uri: vueRange.textDocument.uri,
                    range: vueRange,
                });
            }
        }
        return vueResult;
    }
}
exports.register = register;
//# sourceMappingURL=references.js.map