"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = exports.eventModifiers = exports.vueTags = exports.wordPatterns = exports.triggerCharacter = void 0;
const shared_1 = require("@volar/shared");
const transforms_1 = require("@volar/transforms");
const shared_2 = require("@vue/shared");
const path = require("upath");
const emmet = require("vscode-emmet-helper");
const html = require("vscode-html-languageservice");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const languageServices = require("../utils/languageServices");
const getEmbeddedDocument = require("./embeddedDocument");
exports.triggerCharacter = {
    typescript: [".", "\"", "'", "`", "/", "@", "<", "#"],
    html: ['<', ':', '@', '.' /* Event Modifiers */],
    css: ['.', '@'],
};
exports.wordPatterns = {
    css: /(#?-?\d*\.\d\w*%?)|(::?[\w-]*(?=[^,{;]*[,{]))|(([@#.!])?[\w-?]+%?|[@#!.])/g,
    less: /(#?-?\d*\.\d\w*%?)|(::?[\w-]+(?=[^,{;]*[,{]))|(([@#.!])?[\w-?]+%?|[@#!.])/g,
    scss: /(#?-?\d*\.\d\w*%?)|(::?[\w-]*(?=[^,{;]*[,{]))|(([@$#.!])?[\w-?]+%?|[@#!$.])/g,
    postcss: /(#?-?\d*\.\d\w*%?)|(::?[\w-]*(?=[^,{;]*[,{]))|(([@$#.!])?[\w-?]+%?|[@#!$.])/g, // scss
};
exports.vueTags = [
    {
        name: 'template',
        attributes: [
            {
                name: 'lang',
                values: [
                    { name: 'html' },
                    { name: 'pug' },
                ],
            },
        ],
    },
    {
        name: 'script',
        attributes: [
            {
                name: 'lang',
                values: [
                    { name: 'js' },
                    { name: 'ts' },
                    { name: 'jsx' },
                    { name: 'tsx' },
                ],
            },
            { name: 'setup' },
        ],
    },
    {
        name: 'style',
        attributes: [
            {
                name: 'lang',
                values: [
                    { name: 'css' },
                    { name: 'scss' },
                    { name: 'less' },
                ],
            },
            { name: 'scoped' },
            { name: 'module' },
        ],
    },
];
// https://v3.vuejs.org/api/directives.html#v-on
exports.eventModifiers = {
    stop: 'call event.stopPropagation().',
    prevent: 'call event.preventDefault().',
    capture: 'add event listener in capture mode.',
    self: 'only trigger handler if event was dispatched from this element.',
    // {keyAlias}: 'only trigger handler on certain keys.',
    once: 'trigger handler at most once.',
    left: 'only trigger handler for left button mouse events.',
    right: 'only trigger handler for right button mouse events.',
    middle: 'only trigger handler for middle button mouse events.',
    passive: 'attaches a DOM event with { passive: true }.',
};
function register({ sourceFiles, tsLanguageService }) {
    const getEmbeddedDoc = getEmbeddedDocument.register(arguments[0]);
    return async (uri, position, context, getEmmetConfig) => {
        const sourceFile = sourceFiles.get(uri);
        if (!sourceFile)
            return;
        const tsResult = getTsResult(sourceFile);
        if (tsResult)
            return tsResult;
        const emmetResult = getEmmetResult(sourceFile);
        // precede html for support inline css service
        const cssResult = getCssResult(sourceFile);
        if (cssResult)
            return withEmmetResult(cssResult, emmetResult);
        const htmlResult = getHtmlResult(sourceFile);
        if (htmlResult)
            return withEmmetResult(htmlResult, emmetResult);
        const vueResult = getVueResult(sourceFile);
        if (vueResult)
            return withEmmetResult(vueResult, emmetResult);
        return emmetResult;
        function withEmmetResult(a, b) {
            return {
                isIncomplete: a.isIncomplete || !!(b === null || b === void 0 ? void 0 : b.isIncomplete),
                items: b ? a.items.concat(b.items) : a.items,
            };
        }
        function getTsResult(sourceFile) {
            var _a;
            let result = undefined;
            if ((context === null || context === void 0 ? void 0 : context.triggerCharacter) && !exports.triggerCharacter.typescript.includes(context.triggerCharacter)) {
                return result;
            }
            for (const sourceMap of sourceFile.getTsSourceMaps()) {
                const tsRanges = sourceMap.getMappedRanges(position);
                for (const tsRange of tsRanges) {
                    if (!tsRange.data.capabilities.completion)
                        continue;
                    if (!result) {
                        result = {
                            isIncomplete: false,
                            items: [],
                        };
                    }
                    const quotePreference = tsRange.data.vueTag === 'template' ? 'single' : 'auto';
                    let tsItems = tsLanguageService.doComplete(sourceMap.mappedDocument.uri, tsRange.start, {
                        quotePreference,
                        includeCompletionsForModuleExports: ['script', 'scriptSetup'].includes((_a = tsRange.data.vueTag) !== null && _a !== void 0 ? _a : ''),
                        triggerCharacter: context === null || context === void 0 ? void 0 : context.triggerCharacter,
                    });
                    if (tsRange.data.vueTag === 'template') {
                        tsItems = tsItems.filter(tsItem => {
                            const sortText = Number(tsItem.sortText);
                            if (Number.isNaN(sortText))
                                return true;
                            if (sortText < 4)
                                return true;
                            if (shared_2.isGloballyWhitelisted(tsItem.label))
                                return true;
                            return false;
                        });
                    }
                    const vueItems = tsItems.map(tsItem => {
                        const vueItem = transforms_1.transformCompletionItem(tsItem, tsRange => sourceMap.getSourceRange(tsRange.start, tsRange.end));
                        const data = {
                            uri: uri,
                            docUri: sourceMap.mappedDocument.uri,
                            mode: 'ts',
                            tsItem: tsItem,
                        };
                        vueItem.data = data;
                        return vueItem;
                    });
                    result.items = result.items.concat(vueItems);
                }
            }
            if (result) {
                result.items = result.items.filter(result => result.label.indexOf('__VLS_') === -1);
            }
            return result;
        }
        function getHtmlResult(sourceFile) {
            var _a, _b;
            let result = undefined;
            if ((context === null || context === void 0 ? void 0 : context.triggerCharacter) && !exports.triggerCharacter.html.includes(context.triggerCharacter)) {
                return;
            }
            for (const sourceMap of [...sourceFile.getHtmlSourceMaps(), ...sourceFile.getPugSourceMaps()]) {
                const componentCompletion = sourceFile.getComponentCompletionData();
                const tags = [];
                const tsItems = new Map();
                const globalAttributes = [
                    { name: 'v-if' },
                    { name: 'v-else-if' },
                    { name: 'v-else' },
                    { name: 'v-for' },
                ];
                const slots = [];
                for (const [componentName, { item, bind, on, slot }] of componentCompletion) {
                    if (componentName === '*') {
                        for (const prop of bind) {
                            const name = prop.data.name;
                            if (name.length > 2 && shared_2.hyphenate(name).startsWith('on-')) {
                                const propName = '@' + shared_2.hyphenate(name).substr('on-'.length);
                                const propKey = componentName + ':' + propName;
                                globalAttributes.push({
                                    name: propName,
                                    description: propKey,
                                });
                                tsItems.set(propKey, prop);
                            }
                            else {
                                const propName = ':' + shared_2.hyphenate(name);
                                const propKey = componentName + ':' + propName;
                                globalAttributes.push({
                                    name: propName,
                                    description: propKey,
                                });
                                tsItems.set(propKey, prop);
                            }
                        }
                    }
                    else {
                        const attributes = [];
                        for (const prop of bind) {
                            const name = prop.data.name;
                            if (name.length > 2 && shared_2.hyphenate(name).startsWith('on-')) {
                                const propName = '@' + shared_2.hyphenate(name).substr('on-'.length);
                                const propKey = componentName + ':' + propName;
                                attributes.push({
                                    name: propName,
                                    description: propKey,
                                });
                                tsItems.set(propKey, prop);
                            }
                            else {
                                const propName = ':' + shared_2.hyphenate(name);
                                const propKey = componentName + ':' + propName;
                                attributes.push({
                                    name: propName,
                                    description: propKey,
                                });
                                tsItems.set(propKey, prop);
                            }
                        }
                        for (const event of on) {
                            const propName = '@' + shared_2.hyphenate(event.data.name);
                            const propKey = componentName + ':' + propName;
                            attributes.push({
                                name: propName,
                                description: propKey,
                            });
                            tsItems.set(propKey, event);
                        }
                        for (const _slot of slot) {
                            const propName = '#' + _slot.data.name;
                            const propKey = componentName + ':' + propName;
                            slots.push({
                                name: propName,
                                description: propKey,
                            });
                            tsItems.set(propKey, _slot);
                        }
                        if (item) {
                            tags.push({
                                name: componentName,
                                description: componentName + ':',
                                attributes,
                            });
                            tsItems.set(componentName + ':', item);
                        }
                        else {
                            tags.push({
                                name: componentName,
                                attributes,
                            });
                        }
                    }
                }
                tags.push({
                    name: 'template',
                    attributes: slots,
                });
                const dataProvider = html.newHTMLDataProvider(uri, {
                    version: 1.1,
                    tags,
                    globalAttributes,
                });
                languageServices.html.setDataProviders(true, [dataProvider]);
                for (const htmlRange of sourceMap.getMappedRanges(position)) {
                    if (!result) {
                        result = {
                            isIncomplete: false,
                            items: [],
                        };
                    }
                    const htmlResult = sourceMap.language === 'html'
                        ? languageServices.html.doComplete(sourceMap.mappedDocument, htmlRange.start, sourceMap.htmlDocument)
                        : languageServices.pug.doComplete(sourceMap.pugDocument, htmlRange.start);
                    if (!htmlResult)
                        continue;
                    if (htmlResult.isIncomplete) {
                        result.isIncomplete = true;
                    }
                    const replacement = getReplacement(htmlResult, sourceMap.mappedDocument);
                    if (replacement) {
                        const isEvent = replacement.text.startsWith('@') || replacement.text.startsWith('v-on:');
                        const hasExt = replacement.text.includes('.');
                        if (isEvent && hasExt) {
                            const noExtText = path.trimExt(replacement.text, [], 999);
                            for (const modifier in exports.eventModifiers) {
                                const modifierDes = exports.eventModifiers[modifier];
                                const newItem = {
                                    label: modifier,
                                    filterText: noExtText + '.' + modifier,
                                    documentation: modifierDes,
                                    textEdit: {
                                        range: replacement.textEdit.range,
                                        newText: noExtText + '.' + modifier,
                                    },
                                    kind: vscode_languageserver_types_1.CompletionItemKind.EnumMember,
                                };
                                htmlResult.items.push(newItem);
                            }
                        }
                    }
                    let vueItems = htmlResult.items.map(htmlItem => transforms_1.transformCompletionItem(htmlItem, htmlRange => sourceMap.getSourceRange(htmlRange.start, htmlRange.end)));
                    const htmlItemsMap = new Map();
                    for (const entry of htmlResult.items) {
                        htmlItemsMap.set(entry.label, entry);
                    }
                    for (const vueItem of vueItems) {
                        const documentation = typeof vueItem.documentation === 'string' ? vueItem.documentation : (_a = vueItem.documentation) === null || _a === void 0 ? void 0 : _a.value;
                        const tsItem = documentation ? tsItems.get(documentation) : undefined;
                        if (tsItem) {
                            vueItem.documentation = undefined;
                        }
                        if (vueItem.label.startsWith(':')) {
                            vueItem.sortText = '\u0000' + vueItem.sortText;
                        }
                        else if (vueItem.label.startsWith('@')) {
                            vueItem.sortText = '\u0001' + vueItem.sortText;
                        }
                        if (tsItem && !(documentation === null || documentation === void 0 ? void 0 : documentation.startsWith('*:'))) { // not globalAttributes
                            vueItem.sortText = '\u0000' + vueItem.sortText;
                            vueItem.kind = vscode_languageserver_types_1.CompletionItemKind.Field;
                        }
                        else if (vueItem.label.startsWith('v-')) {
                            vueItem.kind = vscode_languageserver_types_1.CompletionItemKind.Method;
                            vueItem.sortText = '\u0002' + vueItem.sortText;
                        }
                        else {
                            vueItem.sortText = '\u0001' + vueItem.sortText;
                        }
                        const data = {
                            mode: 'html',
                            uri: uri,
                            docUri: sourceMap.mappedDocument.uri,
                            tsItem: tsItem,
                        };
                        vueItem.data = data;
                    }
                    { // filter HTMLAttributes
                        const temp = new Map();
                        for (const item of vueItems) {
                            if (!((_b = temp.get(item.label)) === null || _b === void 0 ? void 0 : _b.documentation)) {
                                temp.set(item.label, item);
                            }
                        }
                        vueItems = [...temp.values()];
                    }
                    result.items = result.items.concat(vueItems);
                }
            }
            return result;
        }
        function getCssResult(sourceFile) {
            var _a;
            let result = undefined;
            if ((context === null || context === void 0 ? void 0 : context.triggerCharacter) && !exports.triggerCharacter.css.includes(context.triggerCharacter)) {
                return;
            }
            for (const sourceMap of sourceFile.getCssSourceMaps()) {
                const cssRanges = sourceMap.getMappedRanges(position);
                for (const cssRange of cssRanges) {
                    if (!result) {
                        result = {
                            isIncomplete: false,
                            items: [],
                        };
                    }
                    const cssLanguageService = languageServices.getCssLanguageService(sourceMap.mappedDocument.languageId);
                    if (!cssLanguageService || !sourceMap.stylesheet)
                        continue;
                    const wordPattern = (_a = exports.wordPatterns[sourceMap.mappedDocument.languageId]) !== null && _a !== void 0 ? _a : exports.wordPatterns.css;
                    const wordStart = shared_1.getWordStart(wordPattern, cssRange.end, sourceMap.mappedDocument);
                    const wordRange = wordStart ? { start: wordStart, end: cssRange.end } : cssRange;
                    const cssResult = cssLanguageService.doComplete(sourceMap.mappedDocument, cssRange.start, sourceMap.stylesheet);
                    if (cssResult.isIncomplete) {
                        result.isIncomplete = true;
                    }
                    const data = {
                        uri: uri,
                        docUri: sourceMap.mappedDocument.uri,
                        mode: 'css',
                    };
                    const vueItems = cssResult.items.map(cssItem => {
                        var _a;
                        const newText = ((_a = cssItem.textEdit) === null || _a === void 0 ? void 0 : _a.newText) || cssItem.insertText || cssItem.label;
                        cssItem.textEdit = vscode_languageserver_types_1.TextEdit.replace(wordRange, newText);
                        const vueItem = transforms_1.transformCompletionItem(cssItem, cssRange => sourceMap.getSourceRange(cssRange.start, cssRange.end));
                        vueItem.data = data;
                        return vueItem;
                    });
                    result.items = result.items.concat(vueItems);
                }
            }
            return result;
        }
        function getVueResult(sourceFile) {
            const embededDoc = getEmbeddedDoc(uri, { start: position, end: position });
            if (embededDoc) {
                let syntax = shared_1.languageIdToSyntax(embededDoc.language);
                if (syntax === 'vue') {
                    const dataProvider = html.newHTMLDataProvider(uri, {
                        version: 1.1,
                        tags: exports.vueTags,
                    });
                    languageServices.html.setDataProviders(false, [dataProvider]);
                    return languageServices.html.doComplete(sourceFile.getTextDocument(), position, sourceFile.getVueHtmlDocument());
                }
            }
        }
        function getEmmetResult(sourceFile) {
            var _a;
            if (!getEmmetConfig)
                return;
            const embededDoc = getEmbeddedDoc(uri, { start: position, end: position });
            if (embededDoc) {
                const emmetConfig = getEmmetConfig(embededDoc.language);
                if (emmetConfig) {
                    let syntax = shared_1.languageIdToSyntax(embededDoc.language);
                    if (syntax === 'vue')
                        syntax = 'html';
                    const doc = (_a = embededDoc.document) !== null && _a !== void 0 ? _a : sourceFile.getTextDocument();
                    const emmetResult = emmet.doComplete(doc, embededDoc.range.start, syntax, emmetConfig);
                    if (emmetResult && embededDoc.sourceMap) {
                        return transforms_1.transformCompletionList(emmetResult, emmetRange => embededDoc.sourceMap.getSourceRange(emmetRange.start, emmetRange.end));
                    }
                    return emmetResult;
                }
            }
        }
    };
}
exports.register = register;
function getReplacement(list, doc) {
    for (const item of list.items) {
        if (item.textEdit && 'range' in item.textEdit) {
            return {
                item: item,
                textEdit: item.textEdit,
                text: doc.getText(item.textEdit.range)
            };
        }
    }
}
//# sourceMappingURL=completion.js.map