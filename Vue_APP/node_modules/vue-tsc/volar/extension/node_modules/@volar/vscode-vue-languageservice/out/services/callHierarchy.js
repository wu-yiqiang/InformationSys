"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const shared_1 = require("@volar/shared");
const upath = require("upath");
const dedupe = require("../utils/dedupe");
function register({ sourceFiles, tsLanguageService }) {
    function onPrepare(document, position) {
        let vueItems = [];
        if (document.languageId !== 'vue') {
            vueItems = worker(document.uri, position);
        }
        else {
            const sourceFile = sourceFiles.get(document.uri);
            if (sourceFile) {
                for (const sourceMap of sourceFile.getTsSourceMaps()) {
                    for (const tsRange of sourceMap.getMappedRanges(position)) {
                        if (!tsRange.data.capabilities.references)
                            continue;
                        const items = worker(sourceMap.mappedDocument.uri, tsRange.start);
                        vueItems = vueItems.concat(items);
                    }
                }
            }
        }
        for (const vueItem of vueItems) {
            vueItem.data = {
                uri: document.uri,
                offset: document.offsetAt(position),
            };
        }
        return dedupe.withLocations(vueItems);
    }
    function onIncomingCalls(item) {
        const tsItems = tsTsCallHierarchyItem(item);
        const tsIncomingItems = tsItems.map(tsLanguageService.provideCallHierarchyIncomingCalls).flat();
        const vueIncomingItems = [];
        for (const tsIncomingItem of tsIncomingItems) {
            const vueResult = toVueCallHierarchyItem(tsIncomingItem.from, tsIncomingItem.fromRanges);
            if (!vueResult)
                continue;
            const [vueItem, vueRanges] = vueResult;
            vueIncomingItems.push({
                from: vueItem,
                fromRanges: vueRanges,
            });
        }
        return dedupe.withCallHierarchyIncomingCalls(vueIncomingItems);
    }
    function onOutgoingCalls(item) {
        const tsItems = tsTsCallHierarchyItem(item);
        const tsIncomingItems = tsItems.map(tsLanguageService.provideCallHierarchyOutgoingCalls).flat();
        const vueIncomingItems = [];
        for (const tsIncomingItem of tsIncomingItems) {
            const vueResult = toVueCallHierarchyItem(tsIncomingItem.to, tsIncomingItem.fromRanges);
            if (!vueResult)
                continue;
            const [vueItem, vueRanges] = vueResult;
            vueIncomingItems.push({
                to: vueItem,
                fromRanges: vueRanges,
            });
        }
        return dedupe.withCallHierarchyOutgoingCalls(vueIncomingItems);
    }
    return {
        onPrepare,
        onIncomingCalls,
        onOutgoingCalls,
    };
    function worker(tsDocUri, tsPos) {
        const vueOrTsItems = [];
        const tsItems = tsLanguageService.prepareCallHierarchy(tsDocUri, tsPos);
        for (const tsItem of tsItems) {
            const result = toVueCallHierarchyItem(tsItem, []);
            if (!result)
                continue;
            const [vueItem] = result;
            if (vueItem) {
                vueOrTsItems.push(vueItem);
            }
        }
        return vueOrTsItems;
    }
    function toVueCallHierarchyItem(tsItem, tsRanges) {
        let isVirtual = false;
        for (const sourceFile of sourceFiles.values()) {
            for (const sourceMap of sourceFile.getTsSourceMaps()) {
                if (sourceMap.mappedDocument.uri !== tsItem.uri) {
                    continue;
                }
                isVirtual = true;
                let vueRange = sourceMap.getSourceRange(tsItem.range.start, tsItem.range.end);
                if (!vueRange) {
                    // TODO: <script> range
                    vueRange = {
                        start: sourceMap.sourceDocument.positionAt(0),
                        end: sourceMap.sourceDocument.positionAt(sourceMap.sourceDocument.getText().length),
                    };
                }
                const vueSelectionRange = sourceMap.getSourceRange(tsItem.selectionRange.start, tsItem.selectionRange.end);
                if (!vueSelectionRange) {
                    continue;
                }
                const vueRanges = tsRanges.map(tsRange => sourceMap.getSourceRange(tsRange.start, tsRange.end)).filter(shared_1.notEmpty);
                const vueItem = {
                    ...tsItem,
                    name: tsItem.name === upath.basename(shared_1.uriToFsPath(sourceMap.mappedDocument.uri)) ? upath.basename(shared_1.uriToFsPath(sourceMap.sourceDocument.uri)) : tsItem.name,
                    uri: sourceMap.sourceDocument.uri,
                    range: vueRange,
                    selectionRange: vueSelectionRange,
                };
                return [vueItem, vueRanges];
            }
        }
        if (!isVirtual) {
            return [tsItem, tsRanges];
        }
    }
    function tsTsCallHierarchyItem(item) {
        if (upath.extname(item.uri) !== '.vue') {
            return [item];
        }
        const tsItems = [];
        const sourceFile = sourceFiles.get(item.uri);
        if (sourceFile) {
            for (const sourceMap of sourceFile.getTsSourceMaps()) {
                const tsLocs = sourceMap.getMappedRanges(item.range.start, item.range.end);
                const tsSelectionRanges = sourceMap.getMappedRanges(item.selectionRange.start, item.selectionRange.end);
                if (tsLocs.length) {
                    for (const tsRange of tsLocs) {
                        if (!tsRange.data.capabilities.references)
                            continue;
                        for (const tsSelectionRange of tsSelectionRanges) {
                            tsItems.push({
                                ...item,
                                uri: sourceMap.mappedDocument.uri,
                                range: tsRange,
                                selectionRange: tsSelectionRange,
                            });
                        }
                    }
                }
                else {
                    for (const maped of sourceMap) {
                        if (maped.data.capabilities.references) {
                            for (const tsSelectionRange of tsSelectionRanges) {
                                tsItems.push({
                                    ...item,
                                    uri: sourceMap.mappedDocument.uri,
                                    range: {
                                        start: sourceMap.mappedDocument.positionAt(0),
                                        end: sourceMap.mappedDocument.positionAt(sourceMap.mappedDocument.getText().length),
                                    },
                                    selectionRange: tsSelectionRange,
                                });
                            }
                            break;
                        }
                    }
                }
            }
        }
        return tsItems;
    }
}
exports.register = register;
//# sourceMappingURL=callHierarchy.js.map