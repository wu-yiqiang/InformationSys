"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServicesManager = void 0;
const shared_1 = require("@volar/shared");
const upath = require("upath");
const serviceHandler_1 = require("./serviceHandler");
function createServicesManager(ts, tsLocalized, connection, documents, rootPaths, getDocVersionForDiag, _onProjectFilesUpdate) {
    let connectionInited = false;
    let filesUpdateTrigger = false;
    const tsConfigNames = ['tsconfig.json', 'jsconfig.json'];
    const tsConfigWatchers = new Map();
    const services = new Map();
    const tsConfigSet = new Set(rootPaths.map(rootPath => ts.sys.readDirectory(rootPath, tsConfigNames, undefined, ['**/*'])).flat());
    const tsConfigs = [...tsConfigSet].filter(tsConfig => tsConfigNames.includes(upath.basename(tsConfig)));
    const checkedProject = new Set();
    for (const tsConfig of tsConfigs) {
        onTsConfigChanged(tsConfig);
    }
    for (const rootPath of rootPaths) {
        ts.sys.watchDirectory(rootPath, async (fileName) => {
            if (tsConfigNames.includes(upath.basename(fileName))) {
                // tsconfig.json changed
                onTsConfigChanged(fileName);
            }
            else {
                // *.vue, *.ts ... changed
                filesUpdateTrigger = true;
                await shared_1.sleep(0);
                if (filesUpdateTrigger) {
                    filesUpdateTrigger = false;
                    for (const [_, service] of services) {
                        service.update();
                    }
                }
            }
        }, true);
    }
    documents.onDidChangeContent(change => {
        for (const [_, service] of services) {
            service.onDocumentUpdated(change.document);
        }
        onDocumentUpdated(change.document);
        // preload
        getMatchService(change.document.uri);
    });
    documents.onDidClose(change => connection.sendDiagnostics({ uri: change.document.uri, diagnostics: [] }));
    return {
        services,
        getMatchService,
        getMatchTsConfig,
        restartAll,
        onConnectionInited,
    };
    async function onDocumentUpdated(changeDoc) {
        if (!getDocVersionForDiag)
            return;
        const otherDocs = [];
        const changedFileName = shared_1.uriToFsPath(changeDoc.uri);
        const isCancel = getIsCancel(changeDoc.uri, changeDoc.version);
        for (const document of documents.all()) {
            if (document.languageId === 'vue' && document.uri !== changeDoc.uri) {
                otherDocs.push(document);
            }
        }
        if (await isCancel())
            return;
        await sendDocumentDiagnostics(changeDoc, changedFileName, isCancel);
        for (const doc of otherDocs) {
            if (await isCancel())
                break;
            await sendDocumentDiagnostics(doc, changedFileName, isCancel);
        }
    }
    async function onFileUpdated(fileName) {
        if (!getDocVersionForDiag)
            return;
        const openedDocs = [];
        for (const document of documents.all()) {
            if (document.languageId === 'vue') {
                openedDocs.push(document);
            }
        }
        for (const doc of openedDocs) {
            await sendDocumentDiagnostics(doc, fileName);
        }
    }
    function getIsCancel(uri, version) {
        let _isCancel = false;
        return async () => {
            if (_isCancel) {
                return true;
            }
            if (getDocVersionForDiag) {
                const clientDocVersion = await getDocVersionForDiag(uri);
                if (clientDocVersion !== undefined && version !== clientDocVersion) {
                    _isCancel = true;
                }
            }
            return _isCancel;
        };
    }
    async function sendDocumentDiagnostics(document, changedFileName, isCancel) {
        const matchTsConfig = getMatchTsConfig(document.uri);
        if (!matchTsConfig)
            return;
        const matchService = services.get(matchTsConfig);
        if (!matchService)
            return;
        if (changedFileName && !matchService.isRelatedFile(changedFileName))
            return;
        const matchLs = matchService.getLanguageService();
        let send = false; // is vue document
        await matchLs.doValidation(document, async (result) => {
            send = true;
            connection.sendDiagnostics({ uri: document.uri, diagnostics: result });
        }, isCancel);
        if (send && !checkedProject.has(matchTsConfig)) {
            checkedProject.add(matchTsConfig);
            const projectValid = matchLs.checkProject();
            if (!projectValid) {
                connection.window.showWarningMessage("Volar cannot offer intellisense auto completion due to your project being a Vue 2 project and not having @vue/runtime-dom installed. You can find more information at https://github.com/johnsoncodehk/volar");
            }
        }
    }
    async function onConnectionInited() {
        connectionInited = true;
        for (const [_, service] of services) {
            service.prepareNextProgress();
        }
    }
    function onTsConfigChanged(tsConfig) {
        var _a, _b;
        for (const doc of documents.all()) {
            if (doc.languageId === 'vue') {
                connection.sendDiagnostics({ uri: doc.uri, diagnostics: [] });
            }
        }
        if (services.has(tsConfig)) {
            (_a = services.get(tsConfig)) === null || _a === void 0 ? void 0 : _a.dispose();
            (_b = tsConfigWatchers.get(tsConfig)) === null || _b === void 0 ? void 0 : _b.close();
            services.delete(tsConfig);
        }
        if (ts.sys.fileExists(tsConfig)) {
            services.set(tsConfig, serviceHandler_1.createServiceHandler(tsConfig, ts, tsLocalized, connection, documents, () => connectionInited, onFileUpdated, _onProjectFilesUpdate));
            tsConfigWatchers.set(tsConfig, ts.sys.watchFile(tsConfig, (fileName, eventKind) => {
                if (eventKind === ts.FileWatcherEventKind.Changed) {
                    onTsConfigChanged(tsConfig);
                }
            }));
        }
        onFileUpdated();
    }
    function restartAll() {
        for (const doc of documents.all()) {
            if (doc.languageId === 'vue') {
                connection.sendDiagnostics({ uri: doc.uri, diagnostics: [] });
            }
        }
        for (const tsConfig of [...services.keys()]) {
            onTsConfigChanged(tsConfig);
        }
        onFileUpdated();
    }
    function getMatchService(uri) {
        var _a;
        const tsConfig = getMatchTsConfig(uri);
        if (tsConfig) {
            return (_a = services.get(tsConfig)) === null || _a === void 0 ? void 0 : _a.getLanguageService();
        }
    }
    function getMatchTsConfig(uri) {
        const matches = getMatchTsConfigs(uri);
        if (matches.length)
            return matches[0];
    }
    function getMatchTsConfigs(uri) {
        var _a;
        const fileName = shared_1.uriToFsPath(uri);
        let firstMatchTsConfigs = [];
        let secondMatchTsConfigs = [];
        for (const kvp of services) {
            const tsConfig = upath.resolve(kvp[0]);
            const parsedCommandLine = kvp[1].getParsedCommandLine();
            const hasVueFile = parsedCommandLine.fileNames.some(fileName => upath.extname(fileName) === '.vue');
            if (!hasVueFile)
                continue;
            const fileNames = new Set(parsedCommandLine.fileNames);
            if (fileNames.has(fileName) || ((_a = kvp[1].getLanguageServiceDontCreate()) === null || _a === void 0 ? void 0 : _a.getTsService().getTextDocument(uri))) {
                const tsConfigDir = upath.dirname(tsConfig);
                if (!upath.relative(tsConfigDir, fileName).startsWith('..')) { // is file under tsconfig.json folder
                    firstMatchTsConfigs.push(tsConfig);
                }
                else {
                    secondMatchTsConfigs.push(tsConfig);
                }
            }
        }
        firstMatchTsConfigs = firstMatchTsConfigs.sort((a, b) => b.split('/').length - a.split('/').length);
        secondMatchTsConfigs = secondMatchTsConfigs.sort((a, b) => b.split('/').length - a.split('/').length);
        return [
            ...firstMatchTsConfigs,
            ...secondMatchTsConfigs,
        ];
    }
}
exports.createServicesManager = createServicesManager;
//# sourceMappingURL=servicesManager.js.map