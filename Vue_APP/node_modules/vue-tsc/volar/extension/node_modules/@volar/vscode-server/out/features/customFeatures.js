"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shared_1 = require("@volar/shared");
const vscode_vue_languageservice_1 = require("@volar/vscode-vue-languageservice");
const fs = require("fs-extra");
const path = require("upath");
const node_1 = require("vscode-languageserver/node");
const instances_1 = require("../instances");
instances_1.connection.onNotification(shared_1.RestartServerNotification.type, async () => {
    instances_1.servicesManager === null || instances_1.servicesManager === void 0 ? void 0 : instances_1.servicesManager.restartAll();
});
instances_1.connection.onRequest(shared_1.RefCloseRequest.type, handler => {
    var _a;
    const document = instances_1.documents.get(handler.textDocument.uri);
    if (!document)
        return;
    return (_a = instances_1.servicesManager === null || instances_1.servicesManager === void 0 ? void 0 : instances_1.servicesManager.getMatchService(document.uri)) === null || _a === void 0 ? void 0 : _a.doRefAutoClose(document, handler.position);
});
instances_1.connection.onRequest(shared_1.D3Request.type, handler => {
    var _a;
    const document = instances_1.documents.get(handler.uri);
    if (!document)
        return;
    return (_a = instances_1.servicesManager === null || instances_1.servicesManager === void 0 ? void 0 : instances_1.servicesManager.getMatchService(document.uri)) === null || _a === void 0 ? void 0 : _a.getD3(document);
});
instances_1.connection.onRequest(shared_1.FormatAllScriptsRequest.type, async (options) => {
    var _a;
    if (!instances_1.servicesManager)
        return;
    const progress = await instances_1.connection.window.createWorkDoneProgress();
    progress.begin('Format', 0, '', true);
    for (const [_, service] of instances_1.servicesManager.services) {
        const ls = service.getLanguageServiceDontCreate();
        if (!ls)
            continue;
        const sourceFiles = ls.getAllSourceFiles();
        let i = 0;
        for (const sourceFile of sourceFiles) {
            if (progress.token.isCancellationRequested) {
                continue;
            }
            const doc = sourceFile.getTextDocument();
            progress.report(i++ / sourceFiles.length * 100, path.relative(ls.rootPath, shared_1.uriToFsPath(doc.uri)));
            const edits = (_a = ls.doFormatting(doc, options)) !== null && _a !== void 0 ? _a : [];
            const workspaceEdit = { changes: { [doc.uri]: edits } };
            await instances_1.connection.workspace.applyEdit(workspaceEdit);
        }
    }
    progress.done();
});
instances_1.connection.onRequest(shared_1.WriteVirtualFilesRequest.type, async () => {
    if (!instances_1.servicesManager)
        return;
    const progress = await instances_1.connection.window.createWorkDoneProgress();
    progress.begin('Write', 0, '', true);
    for (const [_, service] of instances_1.servicesManager.services) {
        const ls = service.getLanguageServiceDontCreate();
        if (!ls)
            continue;
        const globalDocs = ls.getGlobalDocs();
        for (const globalDoc of globalDocs) {
            await fs.writeFile(shared_1.uriToFsPath(globalDoc.uri), globalDoc.getText(), "utf8");
        }
        const sourceFiles = ls.getAllSourceFiles();
        let i = 0;
        for (const sourceFile of sourceFiles) {
            progress.report(i++ / sourceFiles.length * 100, path.relative(ls.rootPath, shared_1.uriToFsPath(sourceFile.uri)));
            for (const [uri, doc] of sourceFile.getTsDocuments()) {
                if (progress.token.isCancellationRequested) {
                    break;
                }
                await fs.writeFile(shared_1.uriToFsPath(uri), doc.getText(), "utf8");
            }
        }
    }
    progress.done();
});
instances_1.connection.onRequest(shared_1.VerifyAllScriptsRequest.type, async () => {
    if (!instances_1.servicesManager)
        return;
    let errors = 0;
    let warnings = 0;
    const progress = await instances_1.connection.window.createWorkDoneProgress();
    progress.begin('Verify', 0, '', true);
    for (const [_, service] of instances_1.servicesManager.services) {
        const ls = service.getLanguageServiceDontCreate();
        if (!ls)
            continue;
        const sourceFiles = ls.getAllSourceFiles();
        let i = 0;
        for (const sourceFile of sourceFiles) {
            progress.report(i++ / sourceFiles.length * 100, path.relative(ls.rootPath, shared_1.uriToFsPath(sourceFile.uri)));
            if (progress.token.isCancellationRequested) {
                continue;
            }
            const doc = sourceFile.getTextDocument();
            let _result = [];
            await ls.doValidation(doc, result => {
                instances_1.connection.sendDiagnostics({ uri: doc.uri, diagnostics: result });
                _result = result;
            });
            errors += _result.filter(error => error.severity === node_1.DiagnosticSeverity.Error).length;
            warnings += _result.filter(error => error.severity === node_1.DiagnosticSeverity.Warning).length;
        }
    }
    progress.done();
    instances_1.connection.window.showInformationMessage(`Verification complete. Found ${errors} errors and ${warnings} warnings.`);
});
instances_1.connection.onRequest(shared_1.RangeSemanticTokensRequest.type, async (handler) => {
    var _a;
    const document = instances_1.documents.get(handler.textDocument.uri);
    if (!document)
        return;
    return (_a = instances_1.servicesManager === null || instances_1.servicesManager === void 0 ? void 0 : instances_1.servicesManager.getMatchService(document.uri)) === null || _a === void 0 ? void 0 : _a.getSemanticTokens(document, handler.range);
});
instances_1.connection.onRequest(shared_1.SemanticTokenLegendRequest.type, () => vscode_vue_languageservice_1.semanticTokenLegend);
instances_1.connection.onRequest(shared_1.TagCloseRequest.type, handler => {
    if (!instances_1.noStateLs)
        return;
    const document = instances_1.documents.get(handler.textDocument.uri);
    if (!document)
        return;
    return instances_1.noStateLs.doAutoClose(document, handler.position);
});
//# sourceMappingURL=customFeatures.js.map