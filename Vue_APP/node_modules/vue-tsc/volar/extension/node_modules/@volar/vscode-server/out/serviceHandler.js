"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServiceHandler = void 0;
const shared_1 = require("@volar/shared");
const vscode_vue_languageservice_1 = require("@volar/vscode-vue-languageservice");
const shared_2 = require("@volar/shared");
const upath = require("upath");
function createServiceHandler(tsConfig, ts, tsLocalized, connection, documents, isConnectionInited, fileUpdatedCb, _onProjectFilesUpdate) {
    let projectVersion = 0;
    let parsedCommandLine;
    let workDoneProgress;
    let vueLs;
    const snapshots = new shared_2.FsPathMap();
    const scripts = new shared_2.FsPathMap();
    const extraScripts = new shared_2.FsPathMap();
    const languageServiceHost = createLanguageServiceHost();
    const disposables = [];
    update();
    prepareNextProgress();
    return {
        update,
        onDocumentUpdated,
        isRelatedFile,
        getLanguageService,
        getLanguageServiceDontCreate: () => vueLs,
        getParsedCommandLine: () => parsedCommandLine,
        dispose,
        prepareNextProgress,
    };
    function getLanguageService() {
        if (!vueLs) {
            vueLs = vscode_vue_languageservice_1.createLanguageService(languageServiceHost, { typescript: ts }, async (p) => {
                if (p === 0) {
                    workDoneProgress === null || workDoneProgress === void 0 ? void 0 : workDoneProgress.begin('Initializing Vue language features');
                }
                if (p < 1) {
                    workDoneProgress === null || workDoneProgress === void 0 ? void 0 : workDoneProgress.report(p * 100);
                }
                else {
                    prepareNextProgress();
                }
            });
        }
        return vueLs;
    }
    async function prepareNextProgress() {
        workDoneProgress === null || workDoneProgress === void 0 ? void 0 : workDoneProgress.done();
        if (isConnectionInited()) {
            workDoneProgress = await connection.window.createWorkDoneProgress();
        }
    }
    function update() {
        parsedCommandLine = createParsedCommandLine(ts, tsConfig);
        const fileNames = new shared_2.FsPathSet(parsedCommandLine.fileNames);
        let changed = false;
        for (const [_, { fileWatcher }] of extraScripts) {
            fileWatcher.close();
        }
        extraScripts.clear();
        const removeKeys = [];
        for (const [key, { fileName, fileWatcher }] of scripts) {
            if (!fileNames.has(fileName)) {
                fileWatcher.close();
                removeKeys.push(key);
                changed = true;
            }
        }
        for (const removeKey of removeKeys) {
            scripts.delete(removeKey);
        }
        for (const fileName of parsedCommandLine.fileNames) {
            if (!scripts.has(fileName)) {
                const fileWatcher = ts.sys.watchFile(fileName, onDriveFileUpdated);
                scripts.set(fileName, {
                    fileName,
                    version: 0,
                    fileWatcher,
                });
                changed = true;
            }
        }
        if (changed) {
            onProjectFilesUpdate();
        }
    }
    function onDocumentUpdated(document) {
        const fileName = shared_1.uriToFsPath(document.uri);
        const snapshot = snapshots.get(fileName);
        if (snapshot) {
            const snapshotLength = snapshot.snapshot.getLength();
            const documentText = document.getText();
            if (snapshotLength === documentText.length
                && snapshot.snapshot.getText(0, snapshotLength) === documentText) {
                return;
            }
        }
        const script = scripts.get(fileName);
        const extraScript = extraScripts.get(fileName);
        if (script) {
            script.version++;
        }
        if (extraScript) {
            extraScript.version++;
        }
        if (script || extraScript) {
            onProjectFilesUpdate();
        }
    }
    function isRelatedFile(fileName) {
        const script = scripts.get(fileName);
        const extraScript = extraScripts.get(fileName);
        return !!script || !!extraScript;
    }
    function onDriveFileUpdated(fileName, eventKind) {
        if (eventKind !== ts.FileWatcherEventKind.Changed) {
            return;
        }
        fileName = shared_1.normalizeFileName(fileName);
        const uri = shared_1.fsPathToUri(fileName);
        if (documents.get(uri)) {
            // this file handle by vscode event
            return;
        }
        const script = scripts.get(fileName);
        if (script) {
            script.version++;
        }
        onProjectFilesUpdate();
        fileUpdatedCb(fileName);
    }
    async function onProjectFilesUpdate() {
        projectVersion++;
        if (_onProjectFilesUpdate) {
            _onProjectFilesUpdate();
        }
    }
    function createLanguageServiceHost() {
        const host = {
            // ts
            getNewLine: () => ts.sys.newLine,
            useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,
            readFile: ts.sys.readFile,
            writeFile: ts.sys.writeFile,
            directoryExists: ts.sys.directoryExists,
            getDirectories: ts.sys.getDirectories,
            readDirectory: ts.sys.readDirectory,
            realpath: ts.sys.realpath,
            // custom
            fileExists,
            getDefaultLibFileName: options => ts.getDefaultLibFilePath(options),
            getProjectVersion: () => projectVersion.toString(),
            getScriptFileNames: () => [
                ...parsedCommandLine.fileNames,
                ...[...extraScripts.values()].map(file => file.fileName).filter(fileName => fileName.endsWith('.vue')), // create virtual files from extra vue scripts
            ],
            getCurrentDirectory: () => upath.dirname(tsConfig),
            getCompilationSettings: () => parsedCommandLine.options,
            getScriptVersion,
            getScriptSnapshot,
        };
        if (tsLocalized) {
            host.getLocalizedDiagnosticMessages = () => tsLocalized;
        }
        return host;
        function fileExists(fileName) {
            var _a, _b, _c, _d, _e;
            fileName = shared_1.normalizeFileName((_c = (_b = (_a = ts.sys).realpath) === null || _b === void 0 ? void 0 : _b.call(_a, fileName)) !== null && _c !== void 0 ? _c : fileName);
            const fileExists = !!((_e = (_d = ts.sys).fileExists) === null || _e === void 0 ? void 0 : _e.call(_d, fileName));
            if (fileExists
                && !scripts.has(fileName)
                && !extraScripts.has(fileName)) {
                const fileWatcher = ts.sys.watchFile(fileName, (_, eventKind) => {
                    const extraFile = extraScripts.get(fileName);
                    if (eventKind === ts.FileWatcherEventKind.Changed) {
                        if (extraFile) {
                            extraFile.version++;
                        }
                    }
                    if (eventKind === ts.FileWatcherEventKind.Deleted) {
                        fileWatcher === null || fileWatcher === void 0 ? void 0 : fileWatcher.close();
                        extraScripts.delete(fileName);
                        snapshots.delete(fileName);
                    }
                    onProjectFilesUpdate();
                });
                extraScripts.set(fileName, {
                    fileName: fileName,
                    version: 0,
                    fileWatcher: fileWatcher,
                });
                if (fileName.endsWith('.vue')) {
                    projectVersion++;
                    vueLs === null || vueLs === void 0 ? void 0 : vueLs.update(false); // create virtual files
                }
            }
            return fileExists;
        }
        function getScriptVersion(fileName) {
            var _a, _b, _c, _d;
            return (_d = (_b = (_a = scripts.get(fileName)) === null || _a === void 0 ? void 0 : _a.version.toString()) !== null && _b !== void 0 ? _b : (_c = extraScripts.get(fileName)) === null || _c === void 0 ? void 0 : _c.version.toString()) !== null && _d !== void 0 ? _d : '';
        }
        function getScriptSnapshot(fileName) {
            const version = getScriptVersion(fileName);
            const cache = snapshots.get(fileName);
            if (cache && cache.version === version) {
                return cache.snapshot;
            }
            const text = getScriptText(fileName);
            if (text !== undefined) {
                const snapshot = ts.ScriptSnapshot.fromString(text);
                snapshots.set(fileName, {
                    version: version.toString(),
                    snapshot,
                });
                return snapshot;
            }
        }
        function getScriptText(fileName) {
            const doc = documents.get(shared_1.fsPathToUri(fileName));
            if (doc) {
                return doc.getText();
            }
            if (ts.sys.fileExists(fileName)) {
                return ts.sys.readFile(fileName, 'utf8');
            }
        }
    }
    function dispose() {
        for (const [_, { fileWatcher }] of scripts) {
            fileWatcher.close();
        }
        for (const [_, { fileWatcher }] of extraScripts) {
            fileWatcher.close();
        }
        if (vueLs) {
            vueLs.dispose();
        }
        for (const disposable of disposables) {
            disposable.dispose();
        }
    }
}
exports.createServiceHandler = createServiceHandler;
function createParsedCommandLine(ts, tsConfig) {
    const parseConfigHost = {
        ...ts.sys,
        readDirectory: (path, extensions, exclude, include, depth) => {
            return ts.sys.readDirectory(path, [...extensions, '.vue'], exclude, include, depth);
        },
    };
    const realTsConfig = ts.sys.realpath(tsConfig);
    const config = ts.readJsonConfigFile(realTsConfig, ts.sys.readFile);
    const content = ts.parseJsonSourceFileConfigFileContent(config, parseConfigHost, upath.dirname(realTsConfig), {}, upath.basename(realTsConfig));
    content.options.outDir = undefined; // TODO: patching ts server broke with outDir + rootDir + composite/incremental
    content.fileNames = content.fileNames.map(shared_1.normalizeFileName);
    return content;
}
//# sourceMappingURL=serviceHandler.js.map