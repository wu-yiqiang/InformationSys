"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLanguageService = exports.getSemanticTokenLegend = void 0;
const ShPlugin = require("typescript-vscode-sh-plugin");
const completions = require("./services/completion");
const completionResolve = require("./services/completionResolve");
const definitions = require("./services/definition");
const typeDefinitions = require("./services/typeDefinition");
const references = require("./services/references");
const prepareRename = require("./services/prepareRename");
const rename = require("./services/rename");
const fileRename = require("./services/fileRename");
const codeActions = require("./services/codeAction");
const codeActionResolve = require("./services/codeActionResolve");
const hover = require("./services/hover");
const signatureHelp = require("./services/signatureHelp");
const selectionRanges = require("./services/selectionRanges");
const diagnostics = require("./services/diagnostics");
const documentHighlight = require("./services/documentHighlight");
const documentSymbol = require("./services/documentSymbol");
const workspaceSymbols = require("./services/workspaceSymbol");
const formatting = require("./services/formatting");
const semanticTokens = require("./services/semanticTokens");
const foldingRanges = require("./services/foldingRanges");
const callHierarchy = require("./services/callHierarchy");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const shared_1 = require("@volar/shared");
var semanticTokens_1 = require("./services/semanticTokens");
Object.defineProperty(exports, "getSemanticTokenLegend", { enumerable: true, get: function () { return semanticTokens_1.getSemanticTokenLegend; } });
function createLanguageService(host, ts) {
    const documents = new Map();
    const shPlugin = ShPlugin({ typescript: ts });
    let languageService = ts.createLanguageService(host);
    languageService = shPlugin.decorate(languageService);
    return {
        raw: languageService,
        host,
        findDefinition: definitions.register(languageService, getTextDocument),
        findTypeDefinition: typeDefinitions.register(languageService, getTextDocument),
        findReferences: references.register(languageService, getTextDocument),
        prepareRename: prepareRename.register(languageService, getTextDocument),
        doRename: rename.register(languageService, getTextDocument),
        onFileName: fileRename.register(languageService, getTextDocument),
        getCodeActions: codeActions.register(languageService, getTextDocument),
        doCodeActionResolve: codeActionResolve.register(languageService, getTextDocument),
        findDocumentHighlights: documentHighlight.register(languageService, getTextDocument, ts),
        findDocumentSymbols: documentSymbol.register(languageService, getTextDocument),
        findWorkspaceSymbols: workspaceSymbols.register(languageService, getTextDocument),
        doComplete: completions.register(languageService, getTextDocument, host.getCurrentDirectory()),
        doCompletionResolve: completionResolve.register(languageService, getTextDocument, ts),
        doHover: hover.register(languageService, getTextDocument, ts),
        doFormatting: formatting.register(languageService, getTextDocument),
        getSignatureHelp: signatureHelp.register(languageService, getTextDocument, ts),
        getSelectionRange: selectionRanges.register(languageService, getTextDocument),
        doValidation: diagnostics.register(languageService, getTextDocument, ts),
        getFoldingRanges: foldingRanges.register(languageService, getTextDocument, ts),
        getDocumentSemanticTokens: semanticTokens.register(languageService, getTextDocument),
        ...callHierarchy.register(languageService, getTextDocument),
        getTextDocument: getTextDocumentNoChecking,
        getTextDocument2: getTextDocument,
        dispose,
    };
    function getTextDocument(uri) {
        var _a;
        const fileName = shared_1.uriToFsPath(uri);
        if (!((_a = languageService.getProgram()) === null || _a === void 0 ? void 0 : _a.getSourceFile(fileName))) {
            return;
        }
        return getTextDocumentNoChecking(uri);
    }
    function getTextDocumentNoChecking(uri) {
        var _a;
        const fileName = shared_1.uriToFsPath(uri);
        const version = host.getScriptVersion(fileName);
        const oldDoc = documents.get(uri);
        if (!oldDoc || oldDoc[0] !== version) {
            const scriptSnapshot = host.getScriptSnapshot(fileName);
            if (scriptSnapshot) {
                const scriptText = scriptSnapshot.getText(0, scriptSnapshot.getLength());
                const document = vscode_languageserver_textdocument_1.TextDocument.create(uri, uri.endsWith('.vue') ? 'vue' : 'typescript', oldDoc ? oldDoc[1].version + 1 : 0, scriptText);
                documents.set(uri, [version, document]);
            }
        }
        return (_a = documents.get(uri)) === null || _a === void 0 ? void 0 : _a[1];
    }
    function dispose() {
        languageService.dispose();
    }
}
exports.createLanguageService = createLanguageService;
//# sourceMappingURL=index.js.map