"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const node_1 = require("vscode-languageserver/node");
const shared_1 = require("@volar/shared");
const rename_1 = require("./rename");
const fixNames = require("../utils/fixNames");
function register(languageService, getTextDocument) {
    return (uri, range, context) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const document = getTextDocument(uri);
        if (!document)
            return;
        const fileName = shared_1.uriToFsPath(document.uri);
        const start = document.offsetAt(range.start);
        const end = document.offsetAt(range.start);
        const errorCodes = context.diagnostics.map(error => error.code);
        let result = [];
        if (!context.only
            || context.only.includes(node_1.CodeActionKind.QuickFix)) {
            try {
                const codeFixes = languageService.getCodeFixesAtPosition(fileName, start, end, errorCodes, {} /* TODO */, {} /* TODO */);
                for (const codeFix of codeFixes) {
                    result = result.concat(transformCodeFix(codeFix));
                }
            }
            catch { }
        }
        if (((_a = context.only) === null || _a === void 0 ? void 0 : _a.includes(node_1.CodeActionKind.Refactor))
            || ((_b = context.only) === null || _b === void 0 ? void 0 : _b.includes(node_1.CodeActionKind.RefactorExtract))
            || ((_c = context.only) === null || _c === void 0 ? void 0 : _c.includes(node_1.CodeActionKind.RefactorInline))
            || ((_d = context.only) === null || _d === void 0 ? void 0 : _d.includes(node_1.CodeActionKind.RefactorRewrite))) {
            try {
                const refactors = languageService.getApplicableRefactors(fileName, { pos: start, end: end }, {} /* TODO */);
                for (const refactor of refactors) {
                    result = result.concat(transformRefactor(refactor));
                }
            }
            catch { }
        }
        if (((_e = context.only) === null || _e === void 0 ? void 0 : _e.includes(node_1.CodeActionKind.Source))
            || ((_f = context.only) === null || _f === void 0 ? void 0 : _f.includes(node_1.CodeActionKind.SourceOrganizeImports))) {
            try {
                const changes = languageService.organizeImports({ type: 'file', fileName: fileName }, {} /* TODO */, {} /* TODO */);
                const edit = rename_1.fileTextChangesToWorkspaceEdit(changes, getTextDocument);
                result.push(node_1.CodeAction.create('Organize Imports', edit, node_1.CodeActionKind.SourceOrganizeImports));
            }
            catch { }
        }
        if (((_g = context.only) === null || _g === void 0 ? void 0 : _g.includes(node_1.CodeActionKind.Source))
            || ((_h = context.only) === null || _h === void 0 ? void 0 : _h.includes(node_1.CodeActionKind.SourceFixAll))) {
            const action = node_1.CodeAction.create('Fix All', node_1.CodeActionKind.SourceFixAll);
            const data = {
                type: 'fixAll',
                fileName,
                fixIds: [
                    fixNames.classIncorrectlyImplementsInterface,
                    fixNames.awaitInSyncFunction,
                    fixNames.unreachableCode,
                ],
            };
            action.data = data;
            result.push(action);
        }
        if ((_j = context.only) === null || _j === void 0 ? void 0 : _j.includes(node_1.CodeActionKind.Source)) {
            {
                const action = node_1.CodeAction.create('Remove all unused code', node_1.CodeActionKind.SourceFixAll);
                const data = {
                    type: 'fixAll',
                    fileName,
                    fixIds: [
                        // not working and throw
                        fixNames.unusedIdentifier,
                        // TODO: remove patching
                        'unusedIdentifier_prefix',
                        'unusedIdentifier_deleteImports',
                        'unusedIdentifier_delete',
                        'unusedIdentifier_infer',
                    ],
                };
                action.data = data;
                result.push(action);
            }
            {
                const action = node_1.CodeAction.create('Add all missing imports', node_1.CodeActionKind.SourceFixAll);
                const data = {
                    type: 'fixAll',
                    fileName,
                    fixIds: [
                        // not working and throw
                        fixNames.fixImport,
                        // TODO: remove patching
                        'fixMissingImport',
                    ],
                };
                action.data = data;
                result.push(action);
            }
        }
        for (const codeAction of result) {
            codeAction.diagnostics = context.diagnostics;
        }
        return result;
        function transformCodeFix(codeFix) {
            const edit = rename_1.fileTextChangesToWorkspaceEdit(codeFix.changes, getTextDocument);
            const codeActions = [];
            const fix = node_1.CodeAction.create(codeFix.description, edit, node_1.CodeActionKind.QuickFix);
            codeActions.push(fix);
            if (codeFix.fixAllDescription && codeFix.fixId) {
                const fixAll = node_1.CodeAction.create(codeFix.fixAllDescription, node_1.CodeActionKind.QuickFix);
                const data = {
                    type: 'fixAll',
                    fileName,
                    fixIds: [codeFix.fixId],
                };
                fixAll.data = data;
                codeActions.push(fixAll);
            }
            return codeActions;
        }
        function transformRefactor(refactor) {
            const codeActions = [];
            for (const action of refactor.actions) {
                const codeAction = node_1.CodeAction.create(action.name, node_1.CodeActionKind.Refactor);
                const data = {
                    type: 'refactor',
                    fileName,
                    range: { pos: start, end: end },
                    refactorName: refactor.name,
                    actionName: action.name,
                };
                codeAction.data = data;
                if (action.notApplicableReason) {
                    codeAction.disabled = { reason: action.notApplicableReason };
                }
                if (refactor.inlineable) {
                    codeAction.isPreferred = true;
                }
                codeActions.push(codeAction);
            }
            return codeActions;
        }
    };
}
exports.register = register;
//# sourceMappingURL=codeAction.js.map