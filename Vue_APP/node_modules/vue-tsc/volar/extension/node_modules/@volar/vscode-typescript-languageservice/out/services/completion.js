"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const PConst = require("../protocol.const");
const node_1 = require("vscode-languageserver/node");
const shared_1 = require("@volar/shared");
const path = require("upath");
function register(languageService, getTextDocument, rootDir) {
    return (uri, position, options) => {
        const document = getTextDocument(uri);
        if (!document)
            return [];
        const fileName = shared_1.uriToFsPath(document.uri);
        const offset = document.offsetAt(position);
        const _options = {
            includeCompletionsWithInsertText: true,
            ...options,
        };
        const info = languageService.getCompletionsAtPosition(fileName, offset, _options);
        if (info === undefined)
            return [];
        const wordRange2 = info.optionalReplacementSpan ? {
            start: info.optionalReplacementSpan.start,
            end: info.optionalReplacementSpan.start + info.optionalReplacementSpan.length,
        } : undefined;
        const wordRange = wordRange2 ? node_1.Range.create(document.positionAt(wordRange2.start), document.positionAt(wordRange2.end)) : undefined;
        const entries = info.entries
            .map(entry => {
            let item = {
                label: entry.name,
                labelDetails: {
                    qualifier: entry.source && path.isAbsolute(entry.source) ? path.relative(rootDir, entry.source) : undefined,
                },
                kind: convertKind(entry.kind),
                sortText: entry.sortText,
                insertText: entry.insertText,
                preselect: entry.isRecommended,
                commitCharacters: getCommitCharacters(entry, info.isNewIdentifierLocation),
                data: {
                    fileName,
                    offset,
                    source: entry.source,
                    name: entry.name,
                    options: _options,
                },
            };
            item = fuzzyCompletionItem(info, document, entry, item);
            return item;
        });
        return entries;
        // from vscode typescript
        function fuzzyCompletionItem(info, document, entry, item) {
            var _a, _b;
            if (entry.kindModifiers) {
                const kindModifiers = entry.kindModifiers.split(/,|\s+/g);
                if (kindModifiers.includes(PConst.KindModifiers.optional)) {
                    if (!item.insertText) {
                        item.insertText = item.label;
                    }
                    if (!item.filterText) {
                        item.filterText = item.label;
                    }
                    item.label += '?';
                }
                if (kindModifiers.includes(PConst.KindModifiers.color)) {
                    item.kind = node_1.CompletionItemKind.Color;
                }
                if (entry.kind === PConst.Kind.script) {
                    for (const extModifier of PConst.KindModifiers.fileExtensionKindModifiers) {
                        if (kindModifiers.includes(extModifier)) {
                            if (entry.name.toLowerCase().endsWith(extModifier)) {
                                item.detail = entry.name;
                            }
                            else {
                                item.detail = entry.name + extModifier;
                            }
                            break;
                        }
                    }
                }
            }
            if (info.isNewIdentifierLocation && entry.replacementSpan) {
                const replaceRange = node_1.Range.create(document.positionAt(entry.replacementSpan.start), document.positionAt(entry.replacementSpan.start + entry.replacementSpan.length));
                item.textEdit = node_1.TextEdit.replace(replaceRange, (_a = item.insertText) !== null && _a !== void 0 ? _a : item.label);
            }
            else {
                if (entry.replacementSpan) {
                    /**
                     * @before
                     * foo. + ['a/b/c'] => foo.['a/b/c']
                     * @after
                     * foo. + ['a/b/c'] => foo['a/b/c']
                     */
                    const replaceRange = !wordRange2
                        ? node_1.Range.create(document.positionAt(entry.replacementSpan.start), document.positionAt(entry.replacementSpan.start + entry.replacementSpan.length))
                        : entry.replacementSpan.start <= wordRange2.start
                            ? node_1.Range.create(document.positionAt(entry.replacementSpan.start), document.positionAt(Math.min(entry.replacementSpan.start + entry.replacementSpan.length, wordRange2.start)))
                            : node_1.Range.create(document.positionAt(Math.max(entry.replacementSpan.start, wordRange2.end)), document.positionAt(entry.replacementSpan.start + entry.replacementSpan.length));
                    item.additionalTextEdits = [node_1.TextEdit.del(replaceRange)];
                }
                if (wordRange) {
                    /**
                     * @before
                     * $f + $foo => $$foo
                     * @after
                     * $f + $foo => $foo
                     */
                    item.textEdit = node_1.TextEdit.replace(wordRange, (_b = item.insertText) !== null && _b !== void 0 ? _b : item.label);
                }
            }
            return item;
        }
        function convertKind(kind) {
            switch (kind) {
                case PConst.Kind.primitiveType:
                case PConst.Kind.keyword:
                    return node_1.CompletionItemKind.Keyword;
                case PConst.Kind.const:
                case PConst.Kind.let:
                case PConst.Kind.variable:
                case PConst.Kind.localVariable:
                case PConst.Kind.alias:
                case PConst.Kind.parameter:
                    return node_1.CompletionItemKind.Variable;
                case PConst.Kind.memberVariable:
                case PConst.Kind.memberGetAccessor:
                case PConst.Kind.memberSetAccessor:
                    return node_1.CompletionItemKind.Field;
                case PConst.Kind.function:
                case PConst.Kind.localFunction:
                    return node_1.CompletionItemKind.Function;
                case PConst.Kind.method:
                case PConst.Kind.constructSignature:
                case PConst.Kind.callSignature:
                case PConst.Kind.indexSignature:
                    return node_1.CompletionItemKind.Method;
                case PConst.Kind.enum:
                    return node_1.CompletionItemKind.Enum;
                case PConst.Kind.enumMember:
                    return node_1.CompletionItemKind.EnumMember;
                case PConst.Kind.module:
                case PConst.Kind.externalModuleName:
                    return node_1.CompletionItemKind.Module;
                case PConst.Kind.class:
                case PConst.Kind.type:
                    return node_1.CompletionItemKind.Class;
                case PConst.Kind.interface:
                    return node_1.CompletionItemKind.Interface;
                case PConst.Kind.warning:
                    return node_1.CompletionItemKind.Text;
                case PConst.Kind.script:
                    return node_1.CompletionItemKind.File;
                case PConst.Kind.directory:
                    return node_1.CompletionItemKind.Folder;
                case PConst.Kind.string:
                    return node_1.CompletionItemKind.Constant;
                default:
                    return node_1.CompletionItemKind.Property;
            }
        }
        function getCommitCharacters(entry, isNewIdentifierLocation) {
            if (isNewIdentifierLocation) {
                return undefined;
            }
            const commitCharacters = [];
            switch (entry.kind) {
                case PConst.Kind.memberGetAccessor:
                case PConst.Kind.memberSetAccessor:
                case PConst.Kind.constructSignature:
                case PConst.Kind.callSignature:
                case PConst.Kind.indexSignature:
                case PConst.Kind.enum:
                case PConst.Kind.interface:
                    commitCharacters.push('.', ';');
                    break;
                case PConst.Kind.module:
                case PConst.Kind.alias:
                case PConst.Kind.const:
                case PConst.Kind.let:
                case PConst.Kind.variable:
                case PConst.Kind.localVariable:
                case PConst.Kind.memberVariable:
                case PConst.Kind.class:
                case PConst.Kind.function:
                case PConst.Kind.method:
                case PConst.Kind.keyword:
                case PConst.Kind.parameter:
                    commitCharacters.push('.', ',', ';');
                    // if (context.enableCallCompletions) {
                    commitCharacters.push('(');
                    // }
                    break;
            }
            return commitCharacters.length === 0 ? undefined : commitCharacters;
        }
    };
}
exports.register = register;
//# sourceMappingURL=completion.js.map