"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEmitDeclarations = exports.register = void 0;
const node_1 = require("vscode-languageserver/node");
const shared_1 = require("@volar/shared");
function register(languageService, getTextDocument, ts) {
    return (uri, options, cancellationToken) => {
        const document = getTextDocument(uri);
        if (!document)
            return [];
        const fileName = shared_1.uriToFsPath(document.uri);
        const program = languageService.getProgram();
        const sourceFile = program === null || program === void 0 ? void 0 : program.getSourceFile(fileName);
        if (!program || !sourceFile)
            return [];
        let errors = [];
        try {
            errors = [
                ...options.semantic ? program.getSemanticDiagnostics(sourceFile, cancellationToken) : [],
                ...options.syntactic ? program.getSyntacticDiagnostics(sourceFile, cancellationToken) : [],
                ...options.suggestion ? languageService.getSuggestionDiagnostics(fileName) : [],
            ];
            if (options.declaration && getEmitDeclarations(program.getCompilerOptions())) {
                errors = errors.concat(program.getDeclarationDiagnostics(sourceFile, cancellationToken));
            }
        }
        catch { }
        return translateDiagnostics(document, errors);
        function translateDiagnostics(document, input) {
            let output = [];
            for (const diag of input) {
                if (diag.start === undefined)
                    continue;
                if (diag.length === undefined)
                    continue;
                const diagnostic = {
                    range: {
                        start: document.positionAt(diag.start),
                        end: document.positionAt(diag.start + diag.length),
                    },
                    severity: translateErrorType(diag.category),
                    source: 'ts',
                    code: diag.code,
                    message: typeof diag.messageText === 'string' ? diag.messageText : diag.messageText.messageText,
                };
                if (diag.reportsUnnecessary) {
                    if (diagnostic.tags === undefined)
                        diagnostic.tags = [];
                    diagnostic.tags.push(node_1.DiagnosticTag.Unnecessary);
                }
                if (diag.reportsDeprecated) {
                    if (diagnostic.tags === undefined)
                        diagnostic.tags = [];
                    diagnostic.tags.push(node_1.DiagnosticTag.Deprecated);
                }
                output.push(diagnostic);
            }
            return output;
        }
        function translateErrorType(input) {
            switch (input) {
                case ts.DiagnosticCategory.Warning: return node_1.DiagnosticSeverity.Warning;
                case ts.DiagnosticCategory.Error: return node_1.DiagnosticSeverity.Error;
                case ts.DiagnosticCategory.Suggestion: return node_1.DiagnosticSeverity.Hint;
                case ts.DiagnosticCategory.Message: return node_1.DiagnosticSeverity.Information;
            }
        }
    };
}
exports.register = register;
function getEmitDeclarations(compilerOptions) {
    return !!(compilerOptions.declaration || compilerOptions.composite);
}
exports.getEmitDeclarations = getEmitDeclarations;
//# sourceMappingURL=diagnostics.js.map