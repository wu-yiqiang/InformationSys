"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileTextChangesToWorkspaceEdit = exports.register = void 0;
const node_1 = require("vscode-languageserver/node");
const shared_1 = require("@volar/shared");
const path = require("upath");
function register(languageService, getTextDocument) {
    return (uri, position, newName) => {
        const document = getTextDocument(uri);
        if (!document)
            return;
        const fileName = shared_1.uriToFsPath(document.uri);
        const offset = document.offsetAt(position);
        const renameInfo = languageService.getRenameInfo(fileName, offset, { allowRenameOfImportPath: true });
        if (!renameInfo.canRename)
            return;
        if (renameInfo.fileToRename) {
            return renameFile(renameInfo.fileToRename, newName);
        }
        const entries = languageService.findRenameLocations(fileName, offset, false, false, true);
        if (!entries)
            return;
        const locations = locationsToWorkspaceEdit(newName, entries, getTextDocument);
        return locations;
    };
    function renameFile(fileToRename, newName) {
        // Make sure we preserve file extension if none provided
        if (!path.extname(newName)) {
            newName += path.extname(fileToRename);
        }
        const dirname = path.dirname(fileToRename);
        const newFilePath = path.join(dirname, newName);
        const response = languageService.getEditsForFileRename(fileToRename, newFilePath, {}, { allowTextChangesInNewFiles: true });
        const edits = fileTextChangesToWorkspaceEdit(response, getTextDocument);
        if (!edits.documentChanges) {
            edits.documentChanges = [];
        }
        edits.documentChanges.push(node_1.RenameFile.create(shared_1.fsPathToUri(fileToRename), shared_1.fsPathToUri(newFilePath)));
        return edits;
    }
}
exports.register = register;
function fileTextChangesToWorkspaceEdit(changes, getTextDocument) {
    const workspaceEdit = {};
    for (const change of changes) {
        if (!workspaceEdit.documentChanges) {
            workspaceEdit.documentChanges = [];
        }
        const uri = shared_1.fsPathToUri(change.fileName);
        if (change.isNewFile) {
            workspaceEdit.documentChanges.push(node_1.CreateFile.create(uri));
        }
        const doc = getTextDocument(uri);
        if (!doc)
            continue;
        const docEdit = node_1.TextDocumentEdit.create({ uri: uri, version: doc.version }, []);
        for (const textChange of change.textChanges) {
            docEdit.edits.push({
                newText: textChange.newText,
                range: {
                    start: doc.positionAt(textChange.span.start),
                    end: doc.positionAt(textChange.span.start + textChange.span.length),
                },
            });
        }
        workspaceEdit.documentChanges.push(docEdit);
    }
    return workspaceEdit;
}
exports.fileTextChangesToWorkspaceEdit = fileTextChangesToWorkspaceEdit;
function locationsToWorkspaceEdit(newText, locations, getTextDocument) {
    const workspaceEdit = {};
    for (const location of locations) {
        if (!workspaceEdit.changes) {
            workspaceEdit.changes = {};
        }
        const uri = shared_1.fsPathToUri(location.fileName);
        const doc = getTextDocument(uri);
        if (!doc)
            continue;
        if (!workspaceEdit.changes[uri]) {
            workspaceEdit.changes[uri] = [];
        }
        let _newText = newText;
        if (location.prefixText)
            _newText = location.prefixText + _newText;
        if (location.suffixText)
            _newText = _newText + location.suffixText;
        workspaceEdit.changes[uri].push({
            newText: _newText,
            range: {
                start: doc.positionAt(location.textSpan.start),
                end: doc.positionAt(location.textSpan.start + location.textSpan.length),
            },
        });
    }
    return workspaceEdit;
}
//# sourceMappingURL=rename.js.map