"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const node_1 = require("vscode-languageserver/node");
const transforms_1 = require("../utils/transforms");
function register(languageService, getTextDocument, ts) {
    return (item, newOffset) => {
        const fileName = item.data.fileName;
        const offset = newOffset !== null && newOffset !== void 0 ? newOffset : item.data.offset;
        const name = item.data.name;
        const source = item.data.source;
        const options = item.data.options;
        let detail;
        try {
            detail = languageService.getCompletionEntryDetails(fileName, offset, name, {}, source, options);
        }
        catch (err) {
            item.detail = `[TS Error] ${err}`;
        }
        const details = [];
        if (detail === null || detail === void 0 ? void 0 : detail.source) {
            const importModule = ts.displayPartsToString(detail.source);
            const importPath = `'${importModule}'`;
            const autoImportLabel = `Auto import from ${importPath}`;
            details.push(autoImportLabel);
        }
        if (detail === null || detail === void 0 ? void 0 : detail.displayParts) {
            details.push(ts.displayPartsToString(detail.displayParts));
        }
        if (detail === null || detail === void 0 ? void 0 : detail.documentation) {
            item.documentation = ts.displayPartsToString(detail.documentation);
        }
        if (details.length)
            item.detail = details.join('\n');
        if (detail === null || detail === void 0 ? void 0 : detail.codeActions) {
            if (!item.additionalTextEdits)
                item.additionalTextEdits = [];
            for (const action of detail.codeActions) {
                for (const changes of action.changes) {
                    const entries = changes.textChanges.map(textChange => {
                        return { fileName, textSpan: textChange.span };
                    });
                    const locs = transforms_1.entriesToLocations(entries, getTextDocument);
                    locs.forEach((loc, index) => {
                        var _a;
                        (_a = item.additionalTextEdits) === null || _a === void 0 ? void 0 : _a.push(node_1.TextEdit.replace(loc.range, changes.textChanges[index].newText));
                    });
                }
            }
        }
        return item;
    };
}
exports.register = register;
//# sourceMappingURL=completionResolve.js.map