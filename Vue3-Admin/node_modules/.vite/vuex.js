import {
  inject,
  reactive,
  watch
} from "./chunk-RLAZP54J.js";
import {
  __name
} from "./chunk-I25YA5I3.js";

// node_modules/vuex/dist/vuex.esm-bundler.js
/*!
 * vuex v4.0.0
 * (c) 2021 Evan You
 * @license MIT
 */
var storeKey = "store";
function useStore(key) {
  if (key === void 0)
    key = null;
  return inject(key !== null ? key : storeKey);
}
__name(useStore, "useStore");
var target = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
var devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;
function devtoolPlugin(store) {
  if (!devtoolHook) {
    return;
  }
  store._devtoolHook = devtoolHook;
  devtoolHook.emit("vuex:init", store);
  devtoolHook.on("vuex:travel-to-state", function(targetState) {
    store.replaceState(targetState);
  });
  store.subscribe(function(mutation, state) {
    devtoolHook.emit("vuex:mutation", mutation, state);
  }, {prepend: true});
  store.subscribeAction(function(action, state) {
    devtoolHook.emit("vuex:action", action, state);
  }, {prepend: true});
}
__name(devtoolPlugin, "devtoolPlugin");
function find(list, f) {
  return list.filter(f)[0];
}
__name(find, "find");
function deepCopy(obj, cache) {
  if (cache === void 0)
    cache = [];
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  var hit = find(cache, function(c) {
    return c.original === obj;
  });
  if (hit) {
    return hit.copy;
  }
  var copy = Array.isArray(obj) ? [] : {};
  cache.push({
    original: obj,
    copy
  });
  Object.keys(obj).forEach(function(key) {
    copy[key] = deepCopy(obj[key], cache);
  });
  return copy;
}
__name(deepCopy, "deepCopy");
function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function(key) {
    return fn(obj[key], key);
  });
}
__name(forEachValue, "forEachValue");
function isObject(obj) {
  return obj !== null && typeof obj === "object";
}
__name(isObject, "isObject");
function isPromise(val) {
  return val && typeof val.then === "function";
}
__name(isPromise, "isPromise");
function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}
__name(assert, "assert");
function partial(fn, arg) {
  return function() {
    return fn(arg);
  };
}
__name(partial, "partial");
var Module = /* @__PURE__ */ __name(function Module2(rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === "function" ? rawState() : rawState) || {};
}, "Module");
var prototypeAccessors = {namespaced: {configurable: true}};
prototypeAccessors.namespaced.get = function() {
  return !!this._rawModule.namespaced;
};
Module.prototype.addChild = /* @__PURE__ */ __name(function addChild(key, module) {
  this._children[key] = module;
}, "addChild");
Module.prototype.removeChild = /* @__PURE__ */ __name(function removeChild(key) {
  delete this._children[key];
}, "removeChild");
Module.prototype.getChild = /* @__PURE__ */ __name(function getChild(key) {
  return this._children[key];
}, "getChild");
Module.prototype.hasChild = /* @__PURE__ */ __name(function hasChild(key) {
  return key in this._children;
}, "hasChild");
Module.prototype.update = /* @__PURE__ */ __name(function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
}, "update");
Module.prototype.forEachChild = /* @__PURE__ */ __name(function forEachChild(fn) {
  forEachValue(this._children, fn);
}, "forEachChild");
Module.prototype.forEachGetter = /* @__PURE__ */ __name(function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
}, "forEachGetter");
Module.prototype.forEachAction = /* @__PURE__ */ __name(function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
}, "forEachAction");
Module.prototype.forEachMutation = /* @__PURE__ */ __name(function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
}, "forEachMutation");
Object.defineProperties(Module.prototype, prototypeAccessors);
var ModuleCollection = /* @__PURE__ */ __name(function ModuleCollection2(rawRootModule) {
  this.register([], rawRootModule, false);
}, "ModuleCollection");
ModuleCollection.prototype.get = /* @__PURE__ */ __name(function get(path) {
  return path.reduce(function(module, key) {
    return module.getChild(key);
  }, this.root);
}, "get");
ModuleCollection.prototype.getNamespace = /* @__PURE__ */ __name(function getNamespace(path) {
  var module = this.root;
  return path.reduce(function(namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + "/" : "");
  }, "");
}, "getNamespace");
ModuleCollection.prototype.update = /* @__PURE__ */ __name(function update$1(rawRootModule) {
  update2([], this.root, rawRootModule);
}, "update$1");
ModuleCollection.prototype.register = /* @__PURE__ */ __name(function register(path, rawModule, runtime) {
  var this$1 = this;
  if (runtime === void 0)
    runtime = true;
  if (true) {
    assertRawModule(path, rawModule);
  }
  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function(rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
}, "register");
ModuleCollection.prototype.unregister = /* @__PURE__ */ __name(function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);
  if (!child) {
    if (true) {
      console.warn("[vuex] trying to unregister module '" + key + "', which is not registered");
    }
    return;
  }
  if (!child.runtime) {
    return;
  }
  parent.removeChild(key);
}, "unregister");
ModuleCollection.prototype.isRegistered = /* @__PURE__ */ __name(function isRegistered(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (parent) {
    return parent.hasChild(key);
  }
  return false;
}, "isRegistered");
function update2(path, targetModule, newModule) {
  if (true) {
    assertRawModule(path, newModule);
  }
  targetModule.update(newModule);
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (true) {
          console.warn("[vuex] trying to add a new module '" + key + "' on hot reloading, manual reload is needed");
        }
        return;
      }
      update2(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
    }
  }
}
__name(update2, "update");
var functionAssert = {
  assert: function(value) {
    return typeof value === "function";
  },
  expected: "function"
};
var objectAssert = {
  assert: function(value) {
    return typeof value === "function" || typeof value === "object" && typeof value.handler === "function";
  },
  expected: 'function or object with "handler" function'
};
var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};
function assertRawModule(path, rawModule) {
  Object.keys(assertTypes).forEach(function(key) {
    if (!rawModule[key]) {
      return;
    }
    var assertOptions = assertTypes[key];
    forEachValue(rawModule[key], function(value, type) {
      assert(assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected));
    });
  });
}
__name(assertRawModule, "assertRawModule");
function makeAssertionMessage(path, key, type, value, expected) {
  var buf = key + " should be " + expected + ' but "' + key + "." + type + '"';
  if (path.length > 0) {
    buf += ' in module "' + path.join(".") + '"';
  }
  buf += " is " + JSON.stringify(value) + ".";
  return buf;
}
__name(makeAssertionMessage, "makeAssertionMessage");
function createStore(options) {
  return new Store(options);
}
__name(createStore, "createStore");
var Store = /* @__PURE__ */ __name(function Store2(options) {
  var this$1 = this;
  if (options === void 0)
    options = {};
  if (true) {
    assert(typeof Promise !== "undefined", "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store2, "store must be called with the new operator.");
  }
  var plugins = options.plugins;
  if (plugins === void 0)
    plugins = [];
  var strict = options.strict;
  if (strict === void 0)
    strict = false;
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = Object.create(null);
  var store = this;
  var ref = this;
  var dispatch2 = ref.dispatch;
  var commit2 = ref.commit;
  this.dispatch = /* @__PURE__ */ __name(function boundDispatch(type, payload) {
    return dispatch2.call(store, type, payload);
  }, "boundDispatch");
  this.commit = /* @__PURE__ */ __name(function boundCommit(type, payload, options2) {
    return commit2.call(store, type, payload, options2);
  }, "boundCommit");
  this.strict = strict;
  var state = this._modules.root.state;
  installModule(this, state, [], this._modules.root);
  resetStoreState(this, state);
  plugins.forEach(function(plugin) {
    return plugin(this$1);
  });
  var useDevtools = options.devtools !== void 0 ? options.devtools : true;
  if (useDevtools) {
    devtoolPlugin(this);
  }
}, "Store");
var prototypeAccessors$1 = {state: {configurable: true}};
Store.prototype.install = /* @__PURE__ */ __name(function install(app, injectKey) {
  app.provide(injectKey || storeKey, this);
  app.config.globalProperties.$store = this;
}, "install");
prototypeAccessors$1.state.get = function() {
  return this._state.data;
};
prototypeAccessors$1.state.set = function(v) {
  if (true) {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};
Store.prototype.commit = /* @__PURE__ */ __name(function commit(_type, _payload, _options) {
  var this$1 = this;
  var ref = unifyObjectStyle(_type, _payload, _options);
  var type = ref.type;
  var payload = ref.payload;
  var options = ref.options;
  var mutation = {type, payload};
  var entry = this._mutations[type];
  if (!entry) {
    if (true) {
      console.error("[vuex] unknown mutation type: " + type);
    }
    return;
  }
  this._withCommit(function() {
    entry.forEach(/* @__PURE__ */ __name(function commitIterator(handler) {
      handler(payload);
    }, "commitIterator"));
  });
  this._subscribers.slice().forEach(function(sub) {
    return sub(mutation, this$1.state);
  });
  if (options && options.silent) {
    console.warn("[vuex] mutation type: " + type + ". Silent option has been removed. Use the filter functionality in the vue-devtools");
  }
}, "commit");
Store.prototype.dispatch = /* @__PURE__ */ __name(function dispatch(_type, _payload) {
  var this$1 = this;
  var ref = unifyObjectStyle(_type, _payload);
  var type = ref.type;
  var payload = ref.payload;
  var action = {type, payload};
  var entry = this._actions[type];
  if (!entry) {
    if (true) {
      console.error("[vuex] unknown action type: " + type);
    }
    return;
  }
  try {
    this._actionSubscribers.slice().filter(function(sub) {
      return sub.before;
    }).forEach(function(sub) {
      return sub.before(action, this$1.state);
    });
  } catch (e) {
    if (true) {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e);
    }
  }
  var result = entry.length > 1 ? Promise.all(entry.map(function(handler) {
    return handler(payload);
  })) : entry[0](payload);
  return new Promise(function(resolve, reject) {
    result.then(function(res) {
      try {
        this$1._actionSubscribers.filter(function(sub) {
          return sub.after;
        }).forEach(function(sub) {
          return sub.after(action, this$1.state);
        });
      } catch (e) {
        if (true) {
          console.warn("[vuex] error in after action subscribers: ");
          console.error(e);
        }
      }
      resolve(res);
    }, function(error) {
      try {
        this$1._actionSubscribers.filter(function(sub) {
          return sub.error;
        }).forEach(function(sub) {
          return sub.error(action, this$1.state, error);
        });
      } catch (e) {
        if (true) {
          console.warn("[vuex] error in error action subscribers: ");
          console.error(e);
        }
      }
      reject(error);
    });
  });
}, "dispatch");
Store.prototype.subscribe = /* @__PURE__ */ __name(function subscribe(fn, options) {
  return genericSubscribe(fn, this._subscribers, options);
}, "subscribe");
Store.prototype.subscribeAction = /* @__PURE__ */ __name(function subscribeAction(fn, options) {
  var subs = typeof fn === "function" ? {before: fn} : fn;
  return genericSubscribe(subs, this._actionSubscribers, options);
}, "subscribeAction");
Store.prototype.watch = /* @__PURE__ */ __name(function watch$1(getter, cb, options) {
  var this$1 = this;
  if (true) {
    assert(typeof getter === "function", "store.watch only accepts a function.");
  }
  return watch(function() {
    return getter(this$1.state, this$1.getters);
  }, cb, Object.assign({}, options));
}, "watch$1");
Store.prototype.replaceState = /* @__PURE__ */ __name(function replaceState(state) {
  var this$1 = this;
  this._withCommit(function() {
    this$1._state.data = state;
  });
}, "replaceState");
Store.prototype.registerModule = /* @__PURE__ */ __name(function registerModule(path, rawModule, options) {
  if (options === void 0)
    options = {};
  if (typeof path === "string") {
    path = [path];
  }
  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, "cannot register the root module by using registerModule.");
  }
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  resetStoreState(this, this.state);
}, "registerModule");
Store.prototype.unregisterModule = /* @__PURE__ */ __name(function unregisterModule(path) {
  var this$1 = this;
  if (typeof path === "string") {
    path = [path];
  }
  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }
  this._modules.unregister(path);
  this._withCommit(function() {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    delete parentState[path[path.length - 1]];
  });
  resetStore(this);
}, "unregisterModule");
Store.prototype.hasModule = /* @__PURE__ */ __name(function hasModule(path) {
  if (typeof path === "string") {
    path = [path];
  }
  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }
  return this._modules.isRegistered(path);
}, "hasModule");
Store.prototype.hotUpdate = /* @__PURE__ */ __name(function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
}, "hotUpdate");
Store.prototype._withCommit = /* @__PURE__ */ __name(function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
}, "_withCommit");
Object.defineProperties(Store.prototype, prototypeAccessors$1);
function genericSubscribe(fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend ? subs.unshift(fn) : subs.push(fn);
  }
  return function() {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  };
}
__name(genericSubscribe, "genericSubscribe");
function resetStore(store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  installModule(store, state, [], store._modules.root, true);
  resetStoreState(store, state, hot);
}
__name(resetStore, "resetStore");
function resetStoreState(store, state, hot) {
  var oldState = store._state;
  store.getters = {};
  store._makeLocalGettersCache = Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computedObj = {};
  forEachValue(wrappedGetters, function(fn, key) {
    computedObj[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      get: function() {
        return computedObj[key]();
      },
      enumerable: true
    });
  });
  store._state = reactive({
    data: state
  });
  if (store.strict) {
    enableStrictMode(store);
  }
  if (oldState) {
    if (hot) {
      store._withCommit(function() {
        oldState.data = null;
      });
    }
  }
}
__name(resetStoreState, "resetStoreState");
function installModule(store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);
  if (module.namespaced) {
    if (store._modulesNamespaceMap[namespace] && true) {
      console.error("[vuex] duplicate namespace " + namespace + " for the namespaced module " + path.join("/"));
    }
    store._modulesNamespaceMap[namespace] = module;
  }
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function() {
      if (true) {
        if (moduleName in parentState) {
          console.warn('[vuex] state field "' + moduleName + '" was overridden by a module with the same name at "' + path.join(".") + '"');
        }
      }
      parentState[moduleName] = module.state;
    });
  }
  var local = module.context = makeLocalContext(store, namespace, path);
  module.forEachMutation(function(mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });
  module.forEachAction(function(action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });
  module.forEachGetter(function(getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });
  module.forEachChild(function(child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}
__name(installModule, "installModule");
function makeLocalContext(store, namespace, path) {
  var noNamespace = namespace === "";
  var local = {
    dispatch: noNamespace ? store.dispatch : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;
      if (!options || !options.root) {
        type = namespace + type;
        if (!store._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }
      return store.dispatch(type, payload);
    },
    commit: noNamespace ? store.commit : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;
      if (!options || !options.root) {
        type = namespace + type;
        if (!store._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }
      store.commit(type, payload, options);
    }
  };
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function() {
        return store.getters;
      } : function() {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function() {
        return getNestedState(store.state, path);
      }
    }
  });
  return local;
}
__name(makeLocalContext, "makeLocalContext");
function makeLocalGetters(store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function(type) {
      if (type.slice(0, splitPos) !== namespace) {
        return;
      }
      var localType = type.slice(splitPos);
      Object.defineProperty(gettersProxy, localType, {
        get: function() {
          return store.getters[type];
        },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }
  return store._makeLocalGettersCache[namespace];
}
__name(makeLocalGetters, "makeLocalGetters");
function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(/* @__PURE__ */ __name(function wrappedMutationHandler(payload) {
    handler.call(store, local.state, payload);
  }, "wrappedMutationHandler"));
}
__name(registerMutation, "registerMutation");
function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(/* @__PURE__ */ __name(function wrappedActionHandler(payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function(err) {
        store._devtoolHook.emit("vuex:error", err);
        throw err;
      });
    } else {
      return res;
    }
  }, "wrappedActionHandler"));
}
__name(registerAction, "registerAction");
function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (true) {
      console.error("[vuex] duplicate getter key: " + type);
    }
    return;
  }
  store._wrappedGetters[type] = /* @__PURE__ */ __name(function wrappedGetter(store2) {
    return rawGetter(local.state, local.getters, store2.state, store2.getters);
  }, "wrappedGetter");
}
__name(registerGetter, "registerGetter");
function enableStrictMode(store) {
  watch(function() {
    return store._state.data;
  }, function() {
    if (true) {
      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, {deep: true, flush: "sync"});
}
__name(enableStrictMode, "enableStrictMode");
function getNestedState(state, path) {
  return path.reduce(function(state2, key) {
    return state2[key];
  }, state);
}
__name(getNestedState, "getNestedState");
function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }
  if (true) {
    assert(typeof type === "string", "expects string as the type, but found " + typeof type + ".");
  }
  return {type, payload, options};
}
__name(unifyObjectStyle, "unifyObjectStyle");
var mapState = normalizeNamespace(function(namespace, states) {
  var res = {};
  if (!isValidMap(states)) {
    console.error("[vuex] mapState: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(states).forEach(function(ref) {
    var key = ref.key;
    var val = ref.val;
    res[key] = /* @__PURE__ */ __name(function mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, "mapState", namespace);
        if (!module) {
          return;
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === "function" ? val.call(this, state, getters) : state[val];
    }, "mappedState");
    res[key].vuex = true;
  });
  return res;
});
var mapMutations = normalizeNamespace(function(namespace, mutations) {
  var res = {};
  if (!isValidMap(mutations)) {
    console.error("[vuex] mapMutations: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(mutations).forEach(function(ref) {
    var key = ref.key;
    var val = ref.val;
    res[key] = /* @__PURE__ */ __name(function mappedMutation() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var commit2 = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, "mapMutations", namespace);
        if (!module) {
          return;
        }
        commit2 = module.context.commit;
      }
      return typeof val === "function" ? val.apply(this, [commit2].concat(args)) : commit2.apply(this.$store, [val].concat(args));
    }, "mappedMutation");
  });
  return res;
});
var mapGetters = normalizeNamespace(function(namespace, getters) {
  var res = {};
  if (!isValidMap(getters)) {
    console.error("[vuex] mapGetters: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(getters).forEach(function(ref) {
    var key = ref.key;
    var val = ref.val;
    val = namespace + val;
    res[key] = /* @__PURE__ */ __name(function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, "mapGetters", namespace)) {
        return;
      }
      if (!(val in this.$store.getters)) {
        console.error("[vuex] unknown getter: " + val);
        return;
      }
      return this.$store.getters[val];
    }, "mappedGetter");
    res[key].vuex = true;
  });
  return res;
});
var mapActions = normalizeNamespace(function(namespace, actions) {
  var res = {};
  if (!isValidMap(actions)) {
    console.error("[vuex] mapActions: mapper parameter must be either an Array or an Object");
  }
  normalizeMap(actions).forEach(function(ref) {
    var key = ref.key;
    var val = ref.val;
    res[key] = /* @__PURE__ */ __name(function mappedAction() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var dispatch2 = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, "mapActions", namespace);
        if (!module) {
          return;
        }
        dispatch2 = module.context.dispatch;
      }
      return typeof val === "function" ? val.apply(this, [dispatch2].concat(args)) : dispatch2.apply(this.$store, [val].concat(args));
    }, "mappedAction");
  });
  return res;
});
var createNamespacedHelpers = /* @__PURE__ */ __name(function(namespace) {
  return {
    mapState: mapState.bind(null, namespace),
    mapGetters: mapGetters.bind(null, namespace),
    mapMutations: mapMutations.bind(null, namespace),
    mapActions: mapActions.bind(null, namespace)
  };
}, "createNamespacedHelpers");
function normalizeMap(map) {
  if (!isValidMap(map)) {
    return [];
  }
  return Array.isArray(map) ? map.map(function(key) {
    return {key, val: key};
  }) : Object.keys(map).map(function(key) {
    return {key, val: map[key]};
  });
}
__name(normalizeMap, "normalizeMap");
function isValidMap(map) {
  return Array.isArray(map) || isObject(map);
}
__name(isValidMap, "isValidMap");
function normalizeNamespace(fn) {
  return function(namespace, map) {
    if (typeof namespace !== "string") {
      map = namespace;
      namespace = "";
    } else if (namespace.charAt(namespace.length - 1) !== "/") {
      namespace += "/";
    }
    return fn(namespace, map);
  };
}
__name(normalizeNamespace, "normalizeNamespace");
function getModuleByNamespace(store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (!module) {
    console.error("[vuex] module namespace not found in " + helper + "(): " + namespace);
  }
  return module;
}
__name(getModuleByNamespace, "getModuleByNamespace");
function createLogger(ref) {
  if (ref === void 0)
    ref = {};
  var collapsed = ref.collapsed;
  if (collapsed === void 0)
    collapsed = true;
  var filter = ref.filter;
  if (filter === void 0)
    filter = /* @__PURE__ */ __name(function(mutation, stateBefore, stateAfter) {
      return true;
    }, "filter");
  var transformer = ref.transformer;
  if (transformer === void 0)
    transformer = /* @__PURE__ */ __name(function(state) {
      return state;
    }, "transformer");
  var mutationTransformer = ref.mutationTransformer;
  if (mutationTransformer === void 0)
    mutationTransformer = /* @__PURE__ */ __name(function(mut) {
      return mut;
    }, "mutationTransformer");
  var actionFilter = ref.actionFilter;
  if (actionFilter === void 0)
    actionFilter = /* @__PURE__ */ __name(function(action, state) {
      return true;
    }, "actionFilter");
  var actionTransformer = ref.actionTransformer;
  if (actionTransformer === void 0)
    actionTransformer = /* @__PURE__ */ __name(function(act) {
      return act;
    }, "actionTransformer");
  var logMutations = ref.logMutations;
  if (logMutations === void 0)
    logMutations = true;
  var logActions = ref.logActions;
  if (logActions === void 0)
    logActions = true;
  var logger = ref.logger;
  if (logger === void 0)
    logger = console;
  return function(store) {
    var prevState = deepCopy(store.state);
    if (typeof logger === "undefined") {
      return;
    }
    if (logMutations) {
      store.subscribe(function(mutation, state) {
        var nextState = deepCopy(state);
        if (filter(mutation, prevState, nextState)) {
          var formattedTime = getFormattedTime();
          var formattedMutation = mutationTransformer(mutation);
          var message = "mutation " + mutation.type + formattedTime;
          startMessage(logger, message, collapsed);
          logger.log("%c prev state", "color: #9E9E9E; font-weight: bold", transformer(prevState));
          logger.log("%c mutation", "color: #03A9F4; font-weight: bold", formattedMutation);
          logger.log("%c next state", "color: #4CAF50; font-weight: bold", transformer(nextState));
          endMessage(logger);
        }
        prevState = nextState;
      });
    }
    if (logActions) {
      store.subscribeAction(function(action, state) {
        if (actionFilter(action, state)) {
          var formattedTime = getFormattedTime();
          var formattedAction = actionTransformer(action);
          var message = "action " + action.type + formattedTime;
          startMessage(logger, message, collapsed);
          logger.log("%c action", "color: #03A9F4; font-weight: bold", formattedAction);
          endMessage(logger);
        }
      });
    }
  };
}
__name(createLogger, "createLogger");
function startMessage(logger, message, collapsed) {
  var startMessage2 = collapsed ? logger.groupCollapsed : logger.group;
  try {
    startMessage2.call(logger, message);
  } catch (e) {
    logger.log(message);
  }
}
__name(startMessage, "startMessage");
function endMessage(logger) {
  try {
    logger.groupEnd();
  } catch (e) {
    logger.log("\u2014\u2014 log end \u2014\u2014");
  }
}
__name(endMessage, "endMessage");
function getFormattedTime() {
  var time = new Date();
  return " @ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
}
__name(getFormattedTime, "getFormattedTime");
function repeat(str, times) {
  return new Array(times + 1).join(str);
}
__name(repeat, "repeat");
function pad(num, maxLength) {
  return repeat("0", maxLength - num.toString().length) + num;
}
__name(pad, "pad");
var index = {
  version: "4.0.0",
  Store,
  storeKey,
  createStore,
  useStore,
  mapState,
  mapMutations,
  mapGetters,
  mapActions,
  createNamespacedHelpers,
  createLogger
};
var vuex_esm_bundler_default = index;

// dep:vuex
var vuex_default = vuex_esm_bundler_default;
export {
  Store,
  createLogger,
  createNamespacedHelpers,
  createStore,
  vuex_default as default,
  mapActions,
  mapGetters,
  mapMutations,
  mapState,
  storeKey,
  useStore
};
//# sourceMappingURL=vuex.js.map
