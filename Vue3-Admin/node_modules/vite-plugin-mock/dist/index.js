"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// src/index.ts
var _vite = require('vite');

// src/createMockServer.ts
var _fs = require('fs');
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _chokidar = require('chokidar'); var _chokidar2 = _interopRequireDefault(_chokidar);
var _chalk = require('chalk'); var _chalk2 = _interopRequireDefault(_chalk);
var _url = require('url'); var _url2 = _interopRequireDefault(_url);
var _fastglob = require('fast-glob'); var _fastglob2 = _interopRequireDefault(_fastglob);
var _mockjs = require('mockjs'); var _mockjs2 = _interopRequireDefault(_mockjs);
var _rollup = require('rollup');
var _rolluppluginesbuild = require('rollup-plugin-esbuild'); var _rolluppluginesbuild2 = _interopRequireDefault(_rolluppluginesbuild);
var _pathtoregexp = require('path-to-regexp');

// src/utils.ts

var toString = Object.prototype.toString;
function is(val, type) {
  return toString.call(val) === `[object ${type}]`;
}
function isFunction(val) {
  return is(val, "Function");
}
function isArray(val) {
  return val && Array.isArray(val);
}
function isRegExp(val) {
  return is(val, "RegExp");
}
function sleep(time) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("");
    }, time);
  });
}
async function loadConfigFromBundledFile(fileName, bundledCode) {
  const extension = _path2.default.extname(fileName);
  const defaultLoader = require.extensions[extension];
  require.extensions[extension] = (module, filename) => {
    if (filename === fileName) {
      module._compile(bundledCode, filename);
    } else {
      defaultLoader(module, filename);
    }
  };
  let config;
  try {
    delete require.cache[fileName];
    const raw = require(fileName);
    config = raw.__esModule ? raw.default : raw;
    require.extensions[extension] = defaultLoader;
  } catch (error) {
  }
  return config;
}

// src/createMockServer.ts
var pathResolve = require("@rollup/plugin-node-resolve");
var mockData = [];
async function createMockServer(opt = {mockPath: "mock", configPath: "vite.mock.config"}) {
  opt = {
    mockPath: "mock",
    watchFiles: true,
    supportTs: true,
    configPath: "vite.mock.config.ts",
    logger: true,
    ...opt
  };
  if (mockData.length > 0)
    return;
  mockData = await getMockConfig(opt);
  const {watchFiles = true} = opt;
  if (watchFiles) {
    const watch = await createWatch(opt);
    watch && watch();
  }
}
async function requestMiddle(opt) {
  const {logger = true} = opt;
  const middleware = async (req, res, next) => {
    let queryParams = {};
    const isGet = req.method && req.method.toUpperCase() === "GET";
    if (isGet && req.url) {
      queryParams = _url2.default.parse(req.url, true);
    }
    const reqUrl = isGet ? queryParams.pathname : req.url;
    const matchReq = mockData.find((item) => {
      if (item.method && item.method.toUpperCase() !== req.method)
        return false;
      if (!reqUrl)
        return false;
      return _pathtoregexp.pathToRegexp.call(void 0, item.url).test(reqUrl);
    });
    if (matchReq) {
      const {response, timeout, statusCode, url: url2} = matchReq;
      if (timeout) {
        await sleep(timeout);
      }
      const urlMatch = _pathtoregexp.match.call(void 0, url2, {decode: decodeURIComponent});
      let query = queryParams.query;
      if (reqUrl) {
        if (isGet) {
          if (JSON.stringify(query) === "{}") {
            query = urlMatch(reqUrl).params || {};
          }
        } else {
          query = urlMatch(reqUrl).params || {};
        }
      }
      const body = await parseJson(req);
      const mockRes = isFunction(response) ? response({body, query}) : response;
      logger && loggerOutput("request invoke", req.url);
      res.setHeader("Content-Type", "application/json");
      res.statusCode = statusCode || 200;
      res.end(JSON.stringify(_mockjs2.default.mock(mockRes)));
      return;
    }
    next();
  };
  return middleware;
}
function createWatch(opt) {
  const {configPath, logger} = opt;
  const {absConfigPath, absMockPath} = getPath(opt);
  if (process.env.VITE_DISABLED_WATCH_MOCK === "true")
    return;
  const watchDir = [];
  const exitsConfigPath = _fs.existsSync.call(void 0, absConfigPath);
  exitsConfigPath && configPath ? watchDir.push(absConfigPath) : watchDir.push(absMockPath);
  const watcher = _chokidar2.default.watch(watchDir, {
    ignoreInitial: true
  });
  const watch = () => {
    watcher.on("all", async (event, file) => {
      logger && loggerOutput(`mock file ${event}`, file);
      mockData = await getMockConfig(opt);
    });
  };
  return watch;
}
function cleanRequireCache(opt) {
  const {absConfigPath, absMockPath} = getPath(opt);
  Object.keys(require.cache).forEach((file) => {
    if (file === absConfigPath || file.indexOf(absMockPath) > -1) {
      delete require.cache[file];
    }
  });
}
function parseJson(req) {
  return new Promise((resolve) => {
    let body = "";
    let jsonStr = "";
    req.on("data", function(chunk) {
      body += chunk;
    });
    req.on("end", function() {
      try {
        jsonStr = JSON.parse(body);
      } catch (err) {
        jsonStr = "";
      }
      resolve(jsonStr);
      return;
    });
  });
}
async function getMockConfig(opt) {
  cleanRequireCache(opt);
  const {absConfigPath, absMockPath} = getPath(opt);
  const {ignore, configPath, supportTs, logger} = opt;
  let ret = [];
  if (configPath && _fs.existsSync.call(void 0, absConfigPath)) {
    logger && loggerOutput(`load mock data from`, absConfigPath);
    ret = await resolveModule(absConfigPath);
  } else {
    const mockFiles = _fastglob2.default.sync(`**/*.${supportTs ? "ts" : "js"}`, {
      cwd: absMockPath
    }).filter((item) => {
      if (!ignore) {
        return true;
      }
      if (isFunction(ignore)) {
        return ignore(item);
      }
      if (isRegExp(ignore)) {
        return !ignore.test(item);
      }
      return true;
    });
    try {
      ret = [];
      for (let index = 0; index < mockFiles.length; index++) {
        const mockFile = mockFiles[index];
        const resultModule = await resolveModule(_path.join.call(void 0, absMockPath, mockFile));
        let mod = resultModule;
        if (!isArray(mod)) {
          mod = [mod];
        }
        ret = [...ret, ...mod];
      }
    } catch (error) {
      loggerOutput(`mock reload error`, error);
      ret = [];
    }
  }
  return ret;
}
async function resolveModule(path3) {
  const nodeResolve = pathResolve.nodeResolve({
    extensions: [".js", ".ts"]
  });
  const bundle = await _rollup.rollup.call(void 0, {
    input: path3,
    treeshake: false,
    plugins: [
      _rolluppluginesbuild2.default.call(void 0, {
        include: /\.[jt]sx?$/,
        exclude: /node_modules/,
        sourceMap: false
      }),
      nodeResolve
    ]
  });
  const {
    output: [{code}]
  } = await bundle.generate({
    exports: "named",
    format: "cjs"
  });
  return await loadConfigFromBundledFile(path3, code);
}
function getPath(opt) {
  const {mockPath, configPath} = opt;
  const cwd = process.cwd();
  const absMockPath = _path.join.call(void 0, cwd, mockPath || "");
  const absConfigPath = _path.join.call(void 0, cwd, configPath || "");
  return {
    absMockPath,
    absConfigPath
  };
}
function loggerOutput(title, msg, type = "info") {
  const tag = type === "info" ? _chalk2.default.cyan.bold(`[vite:mock]`) : _chalk2.default.red.bold(`[vite:mock-server]`);
  return console.log(`${_chalk2.default.dim(new Date().toLocaleTimeString())} ${tag} ${_chalk2.default.green(title)} ${_chalk2.default.dim(msg)}`);
}

// src/index.ts

(async () => {
  try {
    await Promise.resolve().then(() => require("mockjs"));
  } catch (e) {
    throw new Error("vite-plugin-vue-mock requires mockjs to be present in the dependency tree.");
  }
})();
function viteMockServe(opt) {
  const {supportTs = true} = opt;
  const {
    injectFile = _vite.normalizePath.call(void 0, _path2.default.resolve(process.cwd(), `src/main.${supportTs ? "ts" : "js"}`))
  } = opt;
  let isDev = false;
  let config;
  let needSourcemap = false;
  return {
    name: "vite:mock",
    enforce: "pre",
    configResolved(resolvedConfig) {
      config = resolvedConfig;
      isDev = config.command === "serve" && !config.isProduction;
      needSourcemap = resolvedConfig.isProduction && !!resolvedConfig.build.sourcemap;
    },
    configureServer: async ({middlewares}) => {
      const {localEnabled = isDev} = opt;
      if (!localEnabled)
        return;
      createMockServer(opt);
      const middleware = await requestMiddle(opt);
      middlewares.use(middleware);
    },
    async transform(code, id) {
      if (isDev || !id.endsWith(injectFile)) {
        return null;
      }
      const {prodEnabled = true, injectCode = ""} = opt;
      if (!prodEnabled) {
        return null;
      }
      return {
        map: needSourcemap ? this.getCombinedSourcemap() : null,
        code: `${code}
${injectCode}`
      };
    }
  };
}


exports.viteMockServe = viteMockServe;
